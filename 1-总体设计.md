### “世界树”最终架构：完整版 (含REST API层)

### **核心设计哲学**

*   **声明式意图**: 用户通过 YAML 或 API 请求体定义系统的最终期望状态。
*   **幂等执行**: 多次重复执行同一操作，系统状态始终收敛到期望状态，结果一致。
*   **关注点分离**: 每层职责单一且明确，严格隔离用户接口、业务编排、执行引擎和基础服务。
*   **可组合原子性**: 基础操作（原子）被设计为可复用的构建块，能够被灵活组合成复杂的业务逻辑。
*   **基于图的依赖管理**: 通过有向无环图（DAG）精确描述所有操作间的依赖关系，以实现最大化的并发执行和清晰的逻辑流。

---

### **第零层：API 与用户交互 (The API & User Interaction Layer)**

#### **设计思想**:
这是系统的**“外壳”与“前门”**，是外部世界与系统交互的唯一入口。它负责协议转换，将人类可读的命令或机器可读的HTTP请求，翻译成对内部应用服务的调用。

*   **REST API 服务 (`rest/server` 或 `rest/api`)**:
    *   **职责**: 提供一组符合 RESTful 风格的 HTTP 端点，用于以编程方式触发、监控和管理部署任务，实现自动化和系统集成。
    *   **设计**:
        1.  **Web 框架**: 使用轻量级、高性能的 Go Web 框架（如 Gin, Echo）。
        2.  **控制器/处理器 (`rest/server/handler`)**:
            *   **职责**: 解析 HTTP 请求，验证输入数据（如 API 提交的集群配置），并调用**应用服务层 (`pkg/app`)** 来处理核心业务。
            *   **核心原则**: 控制器本身**不包含任何核心业务逻辑**。它是一个纯粹的适配器，负责将 HTTP 协议转换为对应用服务的函数调用，并将结果序列化为 JSON 返回。
        3.  **路由 (`rest/server/router.go`)**: 建立 URL 路径、HTTP 方法与对应处理器函数的映射关系。
        4.  **示例端点 (Endpoints)**:
            *   `POST /api/v1/clusters`: 创建一个新的集群部署任务。请求应是**异步**的，立即返回一个任务ID供后续查询。
            *   `GET /api/v1/tasks/{task_id}`: 查询特定部署任务的状态、日志和结果。

*   **命令行接口 (`cmd/`)**:
    *   **职责**:
        *   使用 `cobra` 等库构建用户友好的命令行界面（如 `kubexm create cluster -f ...`）。
        *   解析命令行参数和标志。
        *   **调用同一个应用服务层 (`rest/app`)** 来启动顶层流程。
        *   接收最终执行结果，以用户友好的方式呈现，并设置正确的程序退出码。
    *   **与 API 的关系**: `cmd` 和 `rest` 互为“兄弟”，它们都是**应用服务层**的客户端，共享相同的核心逻辑入口，仅交互形式不同。

---

### **新增层：应用服务 (The Application Service Layer)**

#### **设计思想**:
为避免在 `cmd` 和 `rest` 中出现重复的业务编排代码，我们引入一个薄薄的**应用服务层**。它是连接“用户意图”（来自CLI或API）和“核心执行逻辑”（`Pipeline`）的**中央调度桥梁**。

*   **应用服务 (`rest/app`)**:
    *   **职责**: 封装**触发一个完整业务流程**所需的高层逻辑，如任务的创建、状态持久化和异步执行管理。
    *   **设计**:
        *   定义清晰的参数结构体（如 `CreateClusterParams`）作为服务方法的输入。
        *   提供核心业务方法（如 `CreateCluster`），该方法：
            1.  （可选）将任务元数据持久化，生成唯一的 `taskID`。
            2.  **启动一个 goroutine** 来异步执行真正的部署工作。
            3.  在这个 goroutine 内部，它会构建 `Runtime` 上下文，创建 `Pipeline`，调用 `Pipeline.Run()`，并在结束后更新任务状态。
            4.  **立即返回 `taskID`**，使API调用方可以解耦并轮询结果。

---

### **第一层：世界观与配置 (The Worldview & Configuration Layer)**

#### **设计思想**:
此层定义了系统的数据模型和配置的入口。它回答了“我们处理的是什么样的数据？”以及“这些数据从哪里来？”这两个基本问题。

*   **数据模型 (pkg/apis)**:
    *   **职责**: 这是系统的领域特定语言 (DSL)。它通过一系列Go结构体，精确地定义了用户可以在 YAML 中声明的所有资源和参数。这是系统理解用户意图的唯一蓝图。
*   **配置加载 (pkg/config)**:
    *   **职责**: 作为一个纯粹的加载器与验证器。它的唯一任务是将用户提供的 YAML 文件安全地转换为内存中的数据模型对象，并执行最基础的语法级校验。
*   **全局常量 (pkg/common)**:
    *   **职责**: 作为一个集中的常量注册表。所有在代码中可能出现的“魔法字符串”（如默认路径、角色名、环境变量键）都应在此处以常量的形式统一定义，以提高可维护性。

---

### **第二层：基础服务 (The Foundational Services Layer)**

#### **设计思想**:
此层提供与具体业务流程完全解耦的、可复用的基础能力。它们是上层建筑可以依赖的、稳固的“基础设施”。

*   **连接抽象 (pkg/connector)**:
    *   **职责**: 这是系统的**“通信协议层”**。它抽象了与目标主机（无论是远程还是本地）建立连接和执行基础命令的细节。通过提供统一的接口，它隐藏了 SSH、本地执行等不同方式的复杂性。连接池的设计是为了高效、安全地管理并发连接资源。
*   **无状态操作库 (pkg/runner)**:
    *   **职责**: 这是一个标准化的主机操作函数库。它封装了所有跨操作系统的原子操作，如文件读写、包管理、服务启停等。
    *   **核心原则**: 该库必须是无状态的。所有函数都通过参数接收它需要操作的目标（通过连接抽象）和相关信息。自身不保存任何会话状态，这使其具备极高的可测试性和可重用性。
*   **通用工具集 (pkg/util)**:
    *   **职责**: 这是一个通用算法和功能集合。它包含与项目业务逻辑完全无关的、可在任何地方使用的纯函数，例如文件哈希计算、网络下载、密码学操作等。
*   **日志服务 (pkg/logger)**:
    *   **职责**: 提供一个全局的、上下文感知的结构化日志服务。所有模块通过它输出日志，能够自动附加任务ID、主机名等上下文信息，便于调试和审计。
*   **作用域缓存 (pkg/cache)**:
    *   **职责**: 提供一个作用域限定的内存键值存储。用于缓存需要频繁读取但不常变化的数据（如主机Facts、计算结果），减少不必要的重复操作，提升性能。
*   **资源抽象 (pkg/resource)**:
    *   **职责**: 抽象化对外部资源（如二进制文件、镜像）的获取逻辑。无论是从本地路径、HTTP服务器还是对象存储下载，上层模块都通过统一接口请求资源，无需关心其来源细节。

---

### **第三层：执行与决策 (The Execution & Decision Layer)**

#### **设计思想**:
这是将用户“声明式意图”翻译成具体“命令式操作”的核心层次。它包含了从最微观的原子操作到宏观的业务逻辑组合，最终生成一个可执行的计划图（DAG）。

*   **原子执行单元 (pkg/step)**:
    *   **职责**: 定义系统中最小的、不可再分的、具有幂等性的执行单元。
    *   **设计**: 每个单元是一个配置驱动的结构体，负责“做一件事”。其接口应包含 `Precheck`（检查是否已完成）、`Run`（执行）和 `Rollback`（回滚）等方法，以保证幂等性和事务性。
*   **战术规划单元 (pkg/task)**:
    *   **职责**: 这是一个**“战术决策者”**或**“子图构建器”**。它根据当前系统状态和用户配置，决定是否需要执行某个特定的子目标（例如，“安装etcd”），并创建、配置一个或多个原子执行单元 (Step) 及其依赖关系，形成一个子图。
*   **战略组合单元 (pkg/module)**:
    *   **职责**: 这是一个**“战略聚合器”**或**“图的链接器”**。它将多个具有相关性的战术规划单元 (Task) 的子图组合在一起，形成一个更大、更完整的业务模块图（例如，“WebServer模块”可能包含“安装Nginx任务”和“配置网站任务”的图）。
*   **端到端流程 (pkg/pipeline)**:
    *   **职责**: 这是最高级别的业务流程编排器，也是**“最终图的组装者”**。它定义了一个完整的端到端流程（如“部署全新集群”），通过按顺序组合多个战略组合单元 (Module) 的图来生成最终的、完整的执行图 (Execution Graph)。

---

### **第四层：运行时与引擎 (The Runtime & Engine Layer)**

#### **设计思想**:
此层是驱动整个系统运转的**“心脏和大脑”**。它负责管理执行期间的上下文状态，并解释和执行上层生成的计划。

*   **执行计划 (pkg/plan)**:
    *   **职责**: 定义一个静态的、可序列化的数据结构，即**执行图 (ExecutionGraph)**。这个结构是第三层（决策层）的输出，也是本层（引擎）的输入。它详细描述了“什么 (Step) 将在哪些主机上执行”，以及它们之间的依赖关系（图的边）。
*   **上下文与状态管理 (pkg/runtime)**:
    *   **职责**:
        1.  **依赖注入 (DI) 容器**: 在启动时被创建，并持有所有共享的服务实例（如 Logger, Runner, Engine）和状态信息（如集群配置、所有主机的连接和Facts）。
        2.  **安全访问控制**: 通过一系列分层接口（Facades），向不同层级（Pipeline, Module, Task, Step）暴露最小必要的功能和数据。这是实现“关注点分离”和防止跨层调用的技术保障。
        3.  **启动与初始化**: 负责在系统启动时，并发地完成所有主机的连接和信息采集，确保在执行任何操作前，整个环境是就绪的。
*   **执行引擎 (pkg/engine)**:
    *   **职责**: 这是一个纯粹的**“计划解释器”**或**“图调度器 (DAG Scheduler)”**。它接收决策层生成的执行计划 (Plan) 和运行时上下文 (Runtime)，然后严格按照图的拓扑顺序，以最大并发度调度并执行相应的原子执行单元 (Step)。它还负责收集每个步骤的执行结果、日志和错误，并最终聚合成一份完整的执行报告。

---

### **架构总结**

通过引入**第零层 (API层)** 和**应用服务层 (`pkg/app`)**，我们实现了：

1.  **多入口支持**: 系统可以同时被命令行和 REST API 驱动，而核心逻辑保持独立。
2.  **异步任务模型**: REST API 调用可以立即返回，并通过任务ID进行状态跟踪，这对于长时间运行的部署任务是必需的。
3.  **更清晰的职责**:
    *   `cmd`/`rest`: 负责与外部世界的**协议转换**（HTTP, 命令行标志）。
    *   `rest/app`: 负责**业务流程的启动和生命周期管理**（如异步执行、状态持久化）。
    *   `pipeline`: 负责**具体业务逻辑的规划**（生成执行图）。
    *   `engine`: 负责**与业务无关的、通用的计划执行**（执行图）。