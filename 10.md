# 2-10

您再次一针见血地指出了我设计中的一个重大缺陷。您完全是对的，**将 OnStepFinished 这样的执行回调放在 runtime.Context 中，是严重的职责不清**。Runtime 只应提供环境，不应包含任何与执行流相关的回调函数。这违背了我们已经确立的“Runtime 啥功能没有，只存上下文”的核心原则。

我为这个反复的错误向您诚挚道歉。您的批评让我意识到，我还没有完全摆脱“中央集权式引擎”的思维惯性。现在，我将彻底纠正这个错误，并提出一个**完全符合“逐层驱动”和“职责分离”模型的、更优雅的日志收集方案**。

---

### **正确的设计：执行者负责报告，调用者负责收集**

这个模型的精髓在于：

1. **Step** 作为最小的执行者，它在执行完毕后，有责任**返回**一个详细的执行结果，而不仅仅是一个 error。
2. **Task** 作为 Step 的调用者，它负责**接收**每个 Step 的执行结果，并决定如何处理（例如，聚合成日志列表）。
3. **Pipeline** -> **Module** -> **Task** 这条链，每一层都负责从下一层收集结果，并向上一层汇报。
4. 最终，在**Service 层**（rest 包中），我们从 Pipeline 的执行结果中拿到所有日志，并将其存入数据库。

这个方案完全不需要在 runtime.Context 中添加任何回调。

---

### **增强方案 V2：通过返回值链传递结果**

### **1. 改造 step 层：返回详细结果**

我们将修改 Step 的 Run 方法签名，让它返回一个包含所有细节的结构体。

`package step

import (
"time"
"github.com/kubexms/kubexms/pkg/connector"
)

// Result 封装了单个 Step 在单个主机上的完整执行结果。
type Result struct {
StepName  string
HostName  string
Status    string // "Succeeded", "Failed", "Skipped"
Stdout    string
Stderr    string
Error     error // Go-native error for control flow
StartTime time.Time
EndTime   time.Time
}

// NewResult is a helper to create a new step result.
func NewResult(stepName, hostName string, startTime time.Time, err error) *Result {
res := &Result{
StepName:  stepName,
HostName:  hostName,
StartTime: startTime,
EndTime:   time.Now(),
Error:     err,
}
if err != nil {
res.Status = "Failed"
// 尝试从错误中提取 stdout/stderr
if cmdErr, ok := err.(*connector.CommandError); ok {
res.Stdout = cmdErr.Stdout
res.Stderr = cmdErr.Stderr
}
} else {
res.Status = "Succeeded"
}
return res
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`package step

import "github.com/kubexms/kubexms/pkg/runtime"

type Step interface {
Name() string
Check(ctx *runtime.Context) (isDone bool, err error)
// Run 方法现在返回一个 *Result
Run(ctx *runtime.Context) *Result
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`package step

func (s *CommandStep) Run(ctx *runtime.Context) *Result {
startTime := time.Now()
_, err := ctx.Host.Runner.Run(ctx.GoContext, s.Cmd, s.Sudo)
return NewResult(s.Name(), ctx.Host.Name, startTime, err)
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **2. 改造 task 层：收集 Step 结果**

Task.Run 方法现在需要收集它调用的所有 Step 的 Result。

`package task

// ... (imports) ...
type Task struct { /* ... */ }

// Run 方法现在返回一个 Result 切片和一个用于控制流程的 error。
func (t *Task) Run(goCtx context.Context, hosts []*runtime.Host, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
// ... (logger, concurrency setup) ...

	// 创建一个线程安全的切片来收集所有主机的日志
	var results []*step.Result
	var mu sync.Mutex

	g, egCtx := errgroup.WithContext(goCtx)
	g.SetLimit(t.Concurrency)

	for _, host := range hosts {
		currentHost := host
		g.Go(func() error {
			hostCtx := runtime.NewHostContext(egCtx, currentHost, cluster)
			for _, s := range t.Steps {
				// 1. Check
				done, err := s.Check(hostCtx)
				if err != nil { /* ... return error ... */ }

				var res *step.Result
				if done {
					// 如果跳过，也创建一个记录
					res = &step.Result{
						StepName: s.Name(),
						HostName: currentHost.Name,
						Status:   "Skipped",
					}
				} else {
					// 2. Run and get result
					res = s.Run(hostCtx)
				}
				
				// 3. Collect result
				mu.Lock()
				results = append(results, res)
				mu.Unlock()

				// 4. Control flow
				if res.Error != nil {
					return res.Error // 如果 Step 失败，将错误传递给 errgroup
				}
			}
			return nil
		})
	}
	
	err := g.Wait()
	return results, err
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **3. 改造 module 和 pipeline 层：传递结果链**

这两层的改造是类似的：它们的 Run 方法都需要接收下一层返回的 Result 列表，然后聚合，再返回给上一层。

`package module

// Run 方法现在返回一个聚合的 Result 切片和 error
func (m *Module) Run(goCtx context.Context, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
// ... (logger, PreRun hook) ...

	var allResults []*step.Result
	var moduleErr error

	for _, t := range m.Tasks {
		targetHosts := selectHostsForTask(cluster, t)
		
		// 调用 Task.Run 并接收结果
		taskResults, taskErr := t.Run(goCtx, targetHosts, cluster)
		
		// 聚合结果
		if taskResults != nil {
			allResults = append(allResults, taskResults...)
		}
		
		if taskErr != nil && !t.IgnoreError {
			moduleErr = taskErr
			break
		}
	}
	
	// ... (PostRun hook) ...
	
	return allResults, moduleErr
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`package pipeline

// Run 方法现在返回最终的、包含所有步骤的 Result 切片和 error
func (p *Pipeline) Run(goCtx context.Context, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
// ... (logger, PreRun hook) ...

	var allResults []*step.Result
	var pipelineErr error

	for _, mod := range p.Modules {
		// ... (IsEnabled check) ...
		
		// 调用 Module.Run 并接收结果
		moduleResults, err := mod.Run(goCtx, cluster)

		// 聚合结果
		if moduleResults != nil {
			allResults = append(allResults, moduleResults...)
		}
		
		if err != nil {
			pipelineErr = err
			break
		}
	}

	// ... (PostRun hook) ...
	
	return allResults, pipelineErr
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **4. 改造 services 层：最终处理结果**

ClusterService 现在是这条结果链的终点。它接收 Pipeline.Run 返回的所有日志，并一次性或分批地存入数据库。

`package services

func (s *ClusterService) runCreateClusterTask(taskID string, configBase64 string) {
s.Store.UpdateTaskStatus(taskID, store.StatusRunning)

	// ... (解码配置, 创建 runtime 的逻辑) ...

	// 创建 Pipeline
	p := pipeline.NewCreateClusterPipeline(cfg)
	
	// 调用增强版的 Run 方法，接收所有结果
	allStepResults, pipelineErr := p.Run(context.Background(), clusterRuntime)

	// 将 step.Result 转换为 store.StepLog
	// 这里的转换是为了保持 API 模型和内部模型的解耦
	logsForDB := make([]*store.StepLog, len(allStepResults))
	for i, res := range allStepResults {
		logsForDB[i] = &store.StepLog{
			StepName: res.StepName,
			HostName: res.HostName,
			Status:   store.TaskStatus(res.Status), // 类型转换
			Stdout:   res.Stdout,
			Stderr:   res.Stderr,
			Error:    res.Error.Error(),
			// ...
		}
	}

	// 将所有日志存入数据库
	// Store 层可以提供一个批量插入的方法 BulkAppendStepLogs
	s.Store.BulkAppendStepLogs(taskID, logsForDB)
	
	// 根据最终结果更新 Task 的整体状态
	if pipelineErr != nil {
		s.Store.UpdateTaskStatus(taskID, store.StatusFailed)
	} else {
		s.Store.UpdateTaskStatus(taskID, store.StatusSucceeded)
	}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **总结：一个更优雅的方案**

这个新方案的优点是显而易见的：

1. **职责极其清晰**: Runtime 保持了它的纯粹性，只提供环境。Step 负责执行并报告结果。Task/Module/Pipeline 负责驱动并收集结果。Service 负责最终处理。
2. **无副作用的回调**: 我们彻底移除了具有副作用的 OnStepFinished 回调，使得所有函数的行为都通过其输入和输出定义，代码流更加线性、易于理解和测试。
3. **类型安全**: 通过定义 step.Result 结构体，我们在编译时就确保了结果的传递是类型安全的。
4. **实时性问题**: 这个方案的一个潜在缺点是，日志是在整个 Pipeline 执行完毕后才被收集和存储的。对于需要“实时”流式日志的场景，之前的回调模型有其优势。但对于大多数后台任务，完成后一次性获取所有日志是完全可以接受的，并且实现上更简单、更健壮。

这是一个在“纯粹性”和“功能性”之间取得了更好平衡的设计，也完全符合您对 Runtime 职责的严格定义。