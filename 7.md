# 2-7

好的，我们已经走到了架构设计的最高层。Step 是细胞，Task 是器官，Module 是系统，而 Pipeline 则是指挥所有系统协同工作的“生命体”。

---

### **Part 7: pkg/pipeline - 工作流管道层 (最终完整版)**

Pipeline 的核心职责是**“定义一个宏大的、端到端的业务目标”**。它通过**编排有序的 Module 列表**来实现这一目标。Pipeline 是用户最终执行的、最顶层的执行蓝图。例如，CreateClusterPipeline、ScaleUpNodePipeline、UpgradeClusterPipeline 都是不同的 Pipeline。

### **设计哲学**

1. **宏观叙事 (Macro-Narrative)**: Pipeline 的定义应该像一部电影的剧本大纲，清晰地描述了整个故事的起承转合。它的 Module 列表的顺序至关重要，定义了整个部署流程的依赖关系（例如，必须先完成预检，再安装容器运行时，然后才能安装 Kubernetes）。
2. **目标驱动 (Goal-Oriented)**: 每个 Pipeline 都为一个明确的、最终的用户目标服务。它的命名应该直接反映这个目标，如 CreateCluster。
3. **最终执行入口 (Final Execution Entrypoint)**: Pipeline 的 Run 方法是整个自动化流程的“点火”按钮。在 cmd 层，我们最终调用的就是这个方法。
4. **可组合性与复用性 (Composability & Reusability)**: 虽然 Pipeline 本身是最高层，但构成它的 Module 是可复用的。同一个 ContainerdModule 既可以被 CreateClusterPipeline 使用，也可以被 ScaleUpNodePipeline 使用。

### **包结构 pkg/pipeline**

`pkg/pipeline/
├── pipeline.go      # 定义 Pipeline 的核心结构体和 Run 方法
└── factory.go       # 提供创建不同类型 Pipeline 的工厂函数`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

---

### **文件 pkg/pipeline/pipeline.go - 核心结构与 Run 方法**

(此部分设计在之前的“逐层驱动模型”中已非常完善，这里是它的最终版本)

`package pipeline

import (
"context"
"fmt"
"github.com/kubexms/kubexms/pkg/module"
"github.com/kubexms/kubexms/pkg/runtime"
"go.uber.org/zap"
)

// Pipeline 是一个有序的 Module 列表，定义了整个端到端工作流。
type Pipeline struct {
Name      string
Modules   []*module.Module
// 钩子可以在 Pipeline 级别定义，作为整个流程的入口和出口。
PreRun    func(cluster *runtime.ClusterRuntime) error
PostRun   func(cluster *runtime.ClusterRuntime, pipelineErr error) error
}

// Run 是整个工作流的起点。它按顺序驱动其内部所有 Module 的执行。
func (p *Pipeline) Run(goCtx context.Context, cluster *runtime.ClusterRuntime) error {
pipelineLogger := cluster.Logger.Sugar().With("pipeline", p.Name)
pipelineLogger.Info("Starting pipeline")

	if p.PreRun != nil {
		pipelineLogger.Info("Executing global PreRun hook")
		if err := p.PreRun(cluster); err != nil {
			return fmt.Errorf("pipeline '%s' PreRun hook failed: %w", p.Name, err)
		}
	}

	var pipelineErr error
	for _, mod := range p.Modules {
		// 检查模块是否启用
		if mod.IsEnabled != nil && !mod.IsEnabled(cluster.ClusterConfig) {
			pipelineLogger.Info("Skipping module as it is disabled", zap.String("module", mod.Name))
			continue
		}
		
		// 调用 Module 的 Run 方法
		err := mod.Run(goCtx, cluster)
		if err != nil {
			pipelineLogger.Error("Module failed, aborting pipeline", "module", mod.Name, "error", err)
			pipelineErr = err
			break // 一个模块失败，整个 Pipeline 失败
		}
	}

	if p.PostRun != nil {
		pipelineLogger.Info("Executing global PostRun hook")
		if err := p.PostRun(cluster, pipelineErr); err != nil {
			// PostRun 钩子失败通常不应覆盖主逻辑的错误，但需要记录
			pipelineLogger.Error("PostRun hook failed", "error", err)
		}
	}

	if pipelineErr == nil {
		pipelineLogger.Info("Pipeline finished successfully.")
	} else {
		pipelineLogger.Error("Pipeline finished with error.", zap.Error(pipelineErr))
	}
	
	return pipelineErr
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **文件 pkg/pipeline/factory.go - Pipeline 工厂**

这里是组装不同工作流的地方。factory.go 包含了一系列工厂函数，每个函数负责创建一个特定目的的 Pipeline 实例。

`package pipeline

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/module"

	// 引入所有业务模块的包
	"github.com/kubexms/kubexms/pkg/preflight"
	"github.com/kubexms/kubexms/pkg/containerd"
	"github.com/kubexms/kubexms/pkg/etcd"
	"github.com/kubexms/kubexms/pkg/ha" // 高可用性模块
	"github.com/kubexms/kubexms/pkg/kubernetes"
	"github.com/kubexms/kubexms/pkg/network"
	"github.com/kubexms/kubexms/pkg/addons" // 集群插件模块
)

// NewCreateClusterPipeline 创建一个用于“从零创建全新集群”的 Pipeline。
func NewCreateClusterPipeline(cfg *config.Cluster) *pipeline.Pipeline {
// Module 的顺序定义了集群创建的逻辑依赖关系
modules := []*module.Module{
// 1. 预检和系统初始化
preflight.NewPreflightModule(cfg),

		// 2. 安装容器运行时
		containerd.NewContainerdModule(cfg), // 或者根据配置选择 DockerModule
		
		// 3. (可选) 配置高可用性基础 (VIP 和 负载均衡器)
		ha.NewHAModule(cfg),

		// 4. 部署 Etcd 集群
		etcd.NewEtcdModule(cfg),
		
		// 5. 部署 Kubernetes 控制平面
		kubernetes.NewControlPlaneModule(cfg),
		
		// 6. 部署 Kubernetes Worker 节点
		kubernetes.NewWorkerNodeModule(cfg),
		
		// 7. 部署网络插件
		network.NewNetworkModule(cfg),
		
		// 8. (可选) 部署集群插件 (如 Metrics Server, CoreDNS 等)
		addons.NewAddonsModule(cfg),
	}

	return &pipeline.Pipeline{
		Name:    "Create Cluster",
		Modules: modules,
	}
}

// NewScaleUpWorkerPipeline 创建一个用于“向现有集群添加 Worker 节点”的 Pipeline。
// 注意，它复用了很多与 CreateClusterPipeline 相同的 Module，但顺序和数量不同。
func NewScaleUpWorkerPipeline(cfg *config.TBA) *pipeline.Pipeline { // 可能需要一个新的配置结构体来描述扩容
modules := []*module.Module{
// 1. 在新节点上执行预检
preflight.NewPreflightModule(cfg),

		// 2. 在新节点上安装容器运行时
		containerd.NewContainerdModule(cfg),
		
		// 3. 在新节点上安装 Kubelet 等二进制文件，并将其加入集群
		kubernetes.NewWorkerNodeModule(cfg), 
		// 注意：NewWorkerNodeModule 内部的 Task 可能需要根据是“创建”还是“扩容”场景有所不同，
		// 这正是 Module 工厂函数强大之处，它可以根据 cfg 中的信息来决策。
	}

	return &pipeline.Pipeline{
		Name:    "Scale-Up Worker Node",
		Modules: modules,
	}
}

// NewUninstallClusterPipeline 创建一个用于“卸载并清理集群”的 Pipeline。
func NewUninstallClusterPipeline(cfg *config.Cluster) *pipeline.Pipeline {
// 卸载的 Module 顺序通常与安装相反
modules := []*module.Module{
// 1. 卸载插件
addons.NewUninstallAddonsModule(cfg),

		// 2. Cordon 和 Drain 节点 (一个特殊的 Task)
		
		// 3. 卸载 Worker 节点
		kubernetes.NewUninstallWorkerModule(cfg),
		
		// 4. 卸载控制平面
		kubernetes.NewUninstallControlPlaneModule(cfg),
		
		// ...以此类推
	}
	
	return &pipeline.Pipeline{
		Name:    "Uninstall Cluster",
		Modules: modules,
	}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **最终执行流程 (cmd 包)**

现在，我们的 cmd 包的逻辑变得异常清晰和简单。

`package main

import (
// ... imports ...
"github.com/kubexms/kubexms/pkg/pipeline"
"github.com/kubexms/kubexms/pkg/runtime"
)

func runCreateCluster(cmd *cobra.Command, args []string) {
// 1. 解析命令行参数和配置文件 -> cfg *config.Cluster
// 2. 初始化日志记录器 -> logger *zap.Logger

    // 3. 创建运行时环境
    clusterRuntime, err := runtime.NewRuntime(cfg, logger)
    if err != nil {
        // handle error
    }

    // 4. 调用工厂函数，创建“创建集群”这个特定的 Pipeline
    p := pipeline.NewCreateClusterPipeline(cfg)

    // 5. 启动 Pipeline！这是整个流程的唯一入口。
    if err := p.Run(context.Background(), clusterRuntime); err != nil {
        // handle error
        os.Exit(1)
    }
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **总结：第七部分 & 整个框架**

Pipeline 层为我们的框架画上了完美的句号。

1. **宏观流程定义**: 它将高度内聚的 Module 串联起来，清晰地定义了一个完整的端到端工作流。
2. **目标导向**: 不同的 Pipeline 对应不同的运维目标（创建、扩容、升级、卸载），使得框架的用途一目了然。
3. **最终入口**: Pipeline.Run 是所有逻辑的最终汇聚点和启动器。

至此，我们完整地设计了一个从底层物理连接到顶层业务流程的、分层清晰、职责明确、高度可扩展的基础设施自动化框架 kubexms。

- **Connector** -> 物理连接
- **Runner** -> 功能性操作
- **Runtime** -> 环境与上下文
- **Step** -> 原子操作 (细胞)
- **Task** -> 功能点 (器官)
- **Module** -> 组件生命周期 (系统)
- **Pipeline** -> 端到端工作流 (生命体)

这个设计严格遵循了您提出的“逐层驱动”模型，实现了极致的关注点分离，其潜力和灵活性都非常巨大。