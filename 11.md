# 2-11

好的，我完全理解您的追求。您希望的是一个**极致的、教科书级别的分层与关注点分离**架构。之前的方案虽然在逻辑上可行，但在“纯粹性”上仍有提升空间。例如，Task 的 Run 方法中既包含了并发调度逻辑，又包含了日志收集逻辑，这本身就是一种职责混合。

让我们进行一次终极的、可能是最纯粹的重构。我们将引入一个新的核心概念——**Executor**，它将所有与“执行”相关的逻辑（并发、调度、日志收集、钩子调用）从 Pipeline/Module/Task 中彻底剥离出来，让它们回归到最纯粹的**数据容器**角色。

---

### **终极方案：引入 Executor 层**

在这个模型中，Pipeline, Module, Task 甚至 Step 都变成了简单的、只读的**“规格 (Specification)”**。它们只描述“做什么”，而不包含任何“如何做”的逻辑。所有的“如何做”都由 Executor 来实现。

**新的、更清晰的依赖关系**:

- **spec**: 定义所有规格（PipelineSpec, ModuleSpec, TaskSpec, StepSpec）。**无任何逻辑**。
- **runtime**: 只提供 Host, Context。
- **step**: 提供 StepSpec 的**具体实现**，它们只包含 Run 逻辑，不包含调度。
- **executor**: 这是新的核心层。它接收一个 PipelineSpec，并负责**解释和执行**它。
- **rest/services**: 调用 executor 来执行任务。

---

### **1. pkg/spec - 纯粹的规格定义层**

这个包现在是整个业务流程的唯一蓝图，不包含任何方法，只有数据结构。

`// pkg/spec/spec.go

package spec

import "github.com/kubexms/kubexms/pkg/runtime"

// StepSpec 定义了 Step 的规格
type StepSpec interface {
GetName() string
// 注意：这里不再有 Run 或 Check 方法，因为 StepSpec 只是数据。
// 具体的执行逻辑在 step 的实现中。
}

// TaskSpec 定义了 Task 的规格
type TaskSpec struct {
Name        string
Steps       []StepSpec // 包含一组 Step 的规格
RunOnRoles  []string
// ... 其他元数据
}

// ModuleSpec 定义了 Module 的规格
type ModuleSpec struct {
Name      string
Tasks     []*TaskSpec
// ... 其他元数据
}

// PipelineSpec 定义了 Pipeline 的规格
type PipelineSpec struct {

	Name    string
	Modules []*ModuleSpec
}

// HookSpec 可以被添加到任何 Spec 中，但它也只是数据
type HookSpec struct {
Name string
// ... Hook 的参数
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

**关键转变**: Pipeline/Module/Task 不再有 Run 方法。它们是纯粹的、可序列化的数据结构。

---

### **2. pkg/step - Step 实现层**

Step 实现现在需要一个方法来匹配 StepSpec 并执行它。

`// pkg/step/registry.go
package step

var registry = make(map[string]StepExecutor)

// StepExecutor 定义了如何执行一个 StepSpec
type StepExecutor interface {
Execute(spec spec.StepSpec, ctx *runtime.Context) *Result
}

func Register(name string, executor StepExecutor) {
registry[name] = executor
}

func GetExecutor(name string) StepExecutor {
return registry[name]
}

// Result 结构体定义保持不变...`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`// pkg/step/command/command.go
package command

// CommandStepSpec 是 CommandStep 的规格
type CommandStepSpec struct {
Cmd  string
Sudo bool
}
func (s *CommandStepSpec) GetName() string { return fmt.Sprintf("Exec: %s", s.Cmd) }

// CommandExecutor 知道如何执行 CommandStepSpec
type CommandExecutor struct{}

func (e *CommandExecutor) Execute(s spec.StepSpec, ctx *runtime.Context) *step.Result {
spec, ok := s.(*CommandStepSpec)
if !ok { /* handle error */ }

	startTime := time.Now()
	_, err := ctx.Host.Runner.Run(ctx.GoContext, spec.Cmd, spec.Sudo)
	return step.NewResult(spec.GetName(), ctx.Host.Name, startTime, err)
}

func init() {
// 在包初始化时，将执行器注册到全局注册表
step.Register("command", &CommandExecutor{})
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

**关键转变**: Step 的规格和它的执行逻辑被分开了。这允许我们有多种方式来执行同一个 StepSpec，极大地提高了灵活性。

---

### **3. pkg/executor - 新的执行核心**

这是本次重构的核心。Executor 包接收一个 PipelineSpec，并负责所有与执行相关的逻辑。

`// pkg/executor/executor.go

package executor

import (
"context"
"github.com/kubexms/kubexms/pkg/runtime"
"github.com/kubexms/kubexms/pkg/spec"
"github.com/kubexms/kubexms/pkg/step"
"golang.org/x/sync/errgroup"
)

// Executor 是唯一的执行驱动器
type Executor struct {
Concurrency int
}

func NewExecutor(concurrency int) *Executor {
return &Executor{Concurrency: concurrency}
}

// RunPipeline 是 Executor 的入口点
func (e *Executor) RunPipeline(goCtx context.Context, p *spec.PipelineSpec, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
var allResults []*step.Result
var pipelineErr error

	// 1. 在这里处理 Pipeline Pre-Hooks

	for _, moduleSpec := range p.Modules {
		// 2. 在这里处理 Module Pre-Hooks

		moduleResults, err := e.runModule(goCtx, moduleSpec, cluster)
		if moduleResults != nil {
			allResults = append(allResults, moduleResults...)
		}
		if err != nil {
			pipelineErr = err
			break
		}
		
		// 3. 在这里处理 Module Post-Hooks
	}

	// 4. 在这里处理 Pipeline Post-Hooks

	return allResults, pipelineErr
}

// runModule 负责解释并执行 ModuleSpec
func (e *Executor) runModule(goCtx context.Context, m *spec.ModuleSpec, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
var allResults []*step.Result
var moduleErr error

	for _, taskSpec := range m.Tasks {
		taskResults, err := e.runTask(goCtx, taskSpec, cluster)
		if taskResults != nil {
			allResults = append(allResults, taskResults...)
		}
		if err != nil {
			// 在这里处理 IgnoreError 逻辑
			moduleErr = err
			break
		}
	}
	return allResults, moduleErr
}

// runTask 负责解释并执行 TaskSpec
func (e *Executor) runTask(goCtx context.Context, t *spec.TaskSpec, cluster *runtime.ClusterRuntime) ([]*step.Result, error) {
targetHosts := e.selectHosts(cluster, t.RunOnRoles)

	var results []*step.Result
	var mu sync.Mutex
	
	g, egCtx := errgroup.WithContext(goCtx)
	g.SetLimit(e.Concurrency)

	for _, host := range targetHosts {
		currentHost := host
		g.Go(func() error {
			hostCtx := runtime.NewHostContext(egCtx, currentHost, cluster)
			for _, stepSpec := range t.Steps {
				// 1. 从注册表中找到 StepSpec 对应的 Executor
				stepExecutor := step.GetExecutor(getSpecTypeName(stepSpec)) // getSpecTypeName 是一个辅助函数
				if stepExecutor == nil { /* handle error */ }

				// 2. 调用 StepExecutor 来执行
				res := stepExecutor.Execute(stepSpec, hostCtx)
				
				mu.Lock()
				results = append(results, res)
				mu.Unlock()

				if res.Error != nil {
					return res.Error
				}
			}
			return nil
		})
	}
	
	err := g.Wait()
	return results, err
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **4. rest/services 层的变化**

Service 层现在变得更简单，它只需要创建 Executor 并调用它。

`// services/cluster_service.go

func (s *ClusterService) runCreateClusterTask(taskID string, ...) {
// ... (解码配置, 创建 runtime 的逻辑) ...

	// 1. 创建 PipelineSpec (这部分逻辑通常在专门的 'builder' 包中)
	pipelineSpec := builder.NewCreateClusterPipelineSpec(cfg)

	// 2. 创建并运行 Executor
	executor := executor.NewExecutor(10)
	allResults, pipelineErr := executor.RunPipeline(context.Background(), pipelineSpec, clusterRuntime)

	// 3. 处理结果
	// ... (将 allResults 存入数据库) ...
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **总结：终极分层模型**

这个模型达到了前所未有的纯粹性：

1. **数据与行为彻底分离**:
    - spec 包是纯粹的**数据**，定义了“是什么”。
    - executor 包是纯粹的**行为**，定义了“如何做”。
    - Pipeline, Module, Task 不再是“对象”，而是可被解释器执行的“代码”或“蓝图”。
2. **职责极度单一**:
    - runtime: 只提供环境。
    - step (实现): 只负责执行最小单元的逻辑。
    - executor: 只负责调度、并发、日志收集、钩子调用等所有与“执行流”相关的逻辑。它是一个通用的 PipelineSpec 解释器。
3. **终极的灵活性**:
    - 我们可以为同一个 PipelineSpec 编写不同的 Executor。例如，一个用于生产环境的并发 Executor，和一个用于调试的、单线程的、带详细步骤暂停的 DebugExecutor。
    - PipelineSpec 可以被轻松地序列化为 JSON/YAML，存储或通过网络传输，因为它不包含任何函数或通道。

这个架构在学术上和工程上都堪称典范，它将**声明式配置**的思想贯彻到了极致。整个 kubexms 的核心变成了一个接收声明式 PipelineSpec 并将其实现的“状态机”或“解释器”。这正是许多现代云原生工具（如 Terraform, Kubernetes Controller）的设计精髓。