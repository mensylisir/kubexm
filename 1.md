# 2-1

### **Part 1: pkg/connector - 物理连接层 (最终详细设计)**

Connector 是整个框架的基石。它的职责是提供一个功能完备、可配置、具备详细错误处理的底层 I/O 通道，屏蔽掉 SSH 和本地执行的实现细节。

### **设计哲学**

- **功能完备 (Feature-Complete)**: 覆盖所有可能的底层操作，包括命令执行、文件传输、系统探测和状态检查。
- **配置驱动 (Configuration-Driven)**: 几乎所有操作都接受一个 Options 结构体，允许进行精细控制。
- **明确的错误 (Explicit Errors)**: 定义自定义错误类型，以便上层可以根据错误类型做出不同决策。
- **上下文感知 (Context-Aware)**: 所有可能耗时的操作都接受 context.Context，以支持超时和取消。

### **包结构 pkg/connector**

`pkg/connector/
├── interface.go      # 定义核心接口和所有数据结构
├── options.go        # 定义各种操作的 Options 结构体
├── errors.go         # 定义自定义错误类型
├── ssh.go            # SSH Connector 的实现
├── local.go          # Local Connector 的实现
└── helpers.go        # 内部辅助函数`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

---

### **options.go - 操作选项**

`package connector

import (
"io"
"time"
)

// ExecOptions 定义了命令执行的所有可配置项
type ExecOptions struct {
// Sudo: 是否使用 'sudo -E' 执行命令。'-E' 保证环境变量得以保留。
Sudo bool
// Timeout: 命令执行的超时时间。默认为 0 (无超时)。
Timeout time.Duration
// Env: 为命令设置额外的环境变量，格式为 "VAR=VALUE"。
Env []string
// Retries: 在命令失败时（非零退出码）的重试次数。
Retries int
// RetryDelay: 每次重试之间的等待时间。
RetryDelay time.Duration
// Fatal: 此命令失败是否为致命错误。上层 Runner 可以捕获此标志并中止流程。
Fatal bool
// Hidden: 是否在日志中隐藏命令本身（用于密码等敏感信息）。
Hidden bool
// Stream: 如果非 nil，命令的 stdout 和 stderr 将实时写入此 Writer。
Stream io.Writer
}

// FileTransferOptions 定义了文件传输的可配置项
type FileTransferOptions struct {
// Permissions: 目标文件的权限模式，e.g., "0644"。如果为空，则使用默认权限。
Permissions string
// Owner: 目标文件的所有者，e.g., "root"。需要 sudo 权限。
Owner string
// Group: 目标文件的用户组，e.g., "root"。需要 sudo 权限。
Group string
// Timeout: 文件传输的超时时间。
Timeout time.Duration
// Sudo: 是否使用 sudo 来写入目标文件（通过写入临时文件再用 sudo mv 的方式）。
Sudo bool
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **errors.go - 自定义错误**

`package connector

import "fmt"

// CommandError 封装了命令执行失败时的详细信息
type CommandError struct {
Cmd        string
ExitCode   int
Stdout     string
Stderr     string
Underlying error
}

func (e *CommandError) Error() string {
return fmt.Sprintf("command '%s' failed with exit code %d: %s", e.Cmd, e.ExitCode, e.Stderr)
}

// ConnectionError 表示连接建立失败
type ConnectionError struct {
Host string
Err  error
}

func (e *ConnectionError) Error() string {
return fmt.Sprintf("failed to connect to host %s: %v", e.Host, e.Err)
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **interface.go - 核心接口与数据结构**

`package connector

import (
"context"
"os"
"time"
)

// FileStat 描述了远程文件或目录的元数据
type FileStat struct {
Name    string      // 文件或目录名
Size    int64       // 文件大小 (字节)
Mode    os.FileMode // 文件权限和模式
ModTime time.Time   // 最后修改时间
IsDir   bool        // 是否为目录
IsExist bool        // 文件或目录是否存在
Sum     string      // 文件的 SHA256 校验和 (如果计算了)
Owner   string      // 文件所有者
Group   string      // 文件所属组
}

// OS 结构体，用于存储远程操作系统的详细信息
type OS struct {
ID        string // e.g., "ubuntu", "centos", "debian", "rhel"
VersionID string // e.g., "22.04", "7", "9", "11"
Codename  string // e.g., "jammy", "bullseye"
Arch      string // e.g., "amd64", "arm64"
Variant   string // e.g., "server"
Kernel    string // 内核版本, e.g., "5.15.0-41-generic"
}

// ConnectionCfg 定义了建立一个连接所需的所有配置
type ConnectionCfg struct {
Host           string
Port           int
User           string
Password       string
PrivateKey     []byte // 私钥内容
PrivateKeyPath string // 私钥文件路径
Timeout        time.Duration
Bastion        *ConnectionCfg // 堡垒机/跳板机配置
}

// Connector 是与主机交互的、功能极其丰富的接口
type Connector interface {
// Connect 使用提供的配置建立并验证连接。
// 这是所有操作的第一步。
Connect(ctx context.Context, cfg ConnectionCfg) error

	// Exec 在已连接的主机上执行一条命令。
	// 返回标准输出、标准错误和包装后的 CommandError。
	Exec(ctx context.Context, cmd string, options *ExecOptions) (stdout, stderr []byte, err error)

	// Copy 将本地文件或目录拷贝到远程主机。
	Copy(ctx context.Context, srcPath, dstPath string, options *FileTransferOptions) error

	// CopyContent 将内存中的字节流直接写入远程文件。
	// 这是渲染模板后上传的理想方法，避免了本地临时文件。
	CopyContent(ctx context.Context, content []byte, dstPath string, options *FileTransferOptions) error

	// Fetch 从远程主机获取文件或目录到本地。
	Fetch(ctx context.Context, remotePath, localPath string) error

	// Stat 获取远程文件或目录的详细状态信息。
	// 如果文件不存在，将返回一个 IsExist=false 的 FileStat 和 nil 错误。
	Stat(ctx context.Context, path string) (*FileStat, error)

	// LookPath 在远程主机的 $PATH 中查找可执行文件 (类似 os.LookPath)。
	// 如果找不到，返回错误。
	LookPath(ctx context.Context, file string) (string, error)

	// GetOS 探测并返回远程操作系统的详细信息。
	// Connector 实现应缓存此结果，避免重复执行探测命令。
	GetOS(ctx context.Context) (*OS, error)
	
	// IsConnected 检查当前连接是否仍然活跃。
	IsConnected() bool

	// Close 优雅地断开连接，释放所有资源。
	Close() error
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **实现细节考量 (ssh.go, local.go)**

- **ssh.go**:
    - **连接管理**: 内部使用 golang.org/x/crypto/ssh。会处理复杂的认证逻辑，包括密码、私钥、Agent，并支持通过 Bastion 配置实现多级跳板。
    - **会话复用**: 对于短时间内的多次 Exec，可以考虑复用 SSH Session，但必须注意会话的生命周期管理，避免状态污染。通常更稳妥的做法是为每个 Exec 创建新会话。
    - **文件传输**: 使用 pkg/sftp 实现 Copy 和 Fetch，以获得比 SCP 更稳定和功能更强的传输能力。
    - **GetOS 实现**: 通过执行 cat /etc/os-release、uname -m、uname -r 等命令并解析其输出来实现。
    - **CopyContent 实现**: 通过 SFTP 创建一个远程文件并写入字节流。
    - **Stat 实现**: 通过 SFTP 的 Lstat 方法实现。
- **local.go**:
    - **Exec 实现**: 使用 os/exec.CommandContext，它原生支持 context 和环境变量。
    - **文件操作**: 直接使用 os 和 io/ioutil 包中的函数。
    - **GetOS 实现**: 在本地执行与 SSH 版本相同的探测命令。
    - **权限问题**: 本地执行时，Sudo 选项需要通过 exec.Command("sudo", ...) 来实现。

---

### **总结：第一部分**

我们已经完成了一个极其详尽和健壮的 Connector 层设计。它具备了以下特点：

1. **接口定义明确**: 每个函数和数据结构都有清晰的文档和用途。
2. **功能强大**: 覆盖了从命令执行到系统探测的各种底层需求。
3. **高度可配置**: Options 结构体提供了对每个操作的精细控制。
4. **错误处理友好**: 自定义的错误类型使得上层逻辑可以轻松处理特定失败场景。
5. **实现思路清晰**: 为 SSH 和 Local 两种实现方式提供了明确的指引。

这个 Connector 层为后续 Runner 层的构建提供了坚如磐石的基础。接下来，我们将基于这个强大的 Connector 来设计同样强大的 Runner 层。