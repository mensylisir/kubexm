# 2-5

### **Part 5: pkg/task - 任务层 (最终完整版)**

Task 的核心职责是**“编排 Step”**。它将一系列原子性的 Step 按照逻辑顺序组合起来，以完成一个**小的、独立的、用户可感知的功能点**。例如，“安装容器运行时”、“配置 etcd 服务”或“加入一个新的 worker 节点”。

### **设计哲学**

1. **功能内聚 (Functional Cohesion)**: 一个 Task 应该只关注一个独立的子目标。它的所有 Step 都应该服务于这个唯一的目标。
2. **声明式 (Declarative)**: Task 的定义应该像一个“配方”或“清单”，清晰地声明了需要执行哪些步骤，而不是包含复杂的命令式逻辑。
3. **上下文无关 (Context-Free Definition)**: Task 的定义本身是静态的。它在创建时被组装好，其执行所需的所有动态信息（如目标主机、集群配置）都在运行时由 Module 或 Pipeline 传入其 Run 方法。
4. **可独立执行 (Independently Executable)**: 虽然 Task 通常在 Module 中被调用，但其设计应该允许它被独立测试或执行，只要为其 Run 方法提供必要的参数即可。

### **包结构 pkg/task**

Task 的实现通常与具体的业务模块紧密相关，因此建议将它们放在相应的模块目录中，而不是一个统一的 pkg/task 目录。

`pkg/
├── etcd/
│   ├── tasks.go      # 定义与 etcd 相关的 Task 工厂函数
├── kubernetes/
│   ├── tasks.go      # 定义与 Kubernetes 核心组件相关的 Task
├── preflight/
│   └── tasks.go
└── containerd/
└── tasks.go`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

我们仍然需要一个顶层的 pkg/task 包来定义 Task 的核心结构体和 Run 方法。

---

### **文件 pkg/task/task.go - 核心结构与 Run 方法**

(此部分设计在之前的“逐层驱动模型”中已非常完善，这里是它的最终版本)

`package task

import (
"context"
"fmt"
"github.com/kubexms/kubexms/pkg/runtime"
"github.com/kubexms/kubexms/pkg/step"
"golang.org/x/sync/errgroup"
)

// Task 代表一个为实现小的、独立的功能而编排的一组有序的 Step。
type Task struct {
Name        string
Steps       []step.Step
RunOnRoles  []string                      // 在哪些角色的主机上运行
Filter      func(host *runtime.Host) bool // 更精细的动态主机过滤逻辑
IgnoreError bool                          // 此任务失败是否应中止上层 Module
Concurrency int                           // 在不同主机上执行此任务的并发数
}

// Run 是 Task 的核心方法。它接收目标主机和全局运行时，并负责并发地驱动其内部所有 Steps 的执行。
func (t *Task) Run(goCtx context.Context, hosts []*runtime.Host, cluster *runtime.ClusterRuntime) error {
taskLogger := cluster.Logger.Sugar().With("task", t.Name)
taskLogger.Info("Running task")

	if len(hosts) == 0 {
		taskLogger.Info("No target hosts for task, skipping.")
		return nil
	}

	g, egCtx := errgroup.WithContext(goCtx)
	concurrency := t.Concurrency
	if concurrency == 0 {
		concurrency = 10 // 默认并发数
	}
	g.SetLimit(concurrency)

	for _, host := range hosts {
		currentHost := host
		g.Go(func() error {
			// 为每个主机创建一个独立的上下文
			hostCtx := runtime.NewHostContext(egCtx, currentHost, cluster)
			for _, s := range t.Steps {
				stepLogger := hostCtx.Logger.With("step", s.Name())
				
				// 1. 幂等性检查
				done, err := s.Check(hostCtx)
				if err != nil {
					err = fmt.Errorf("step '%s' check failed on host '%s': %w", s.Name(), currentHost.Name, err)
					stepLogger.Error(err)
					return err
				}
				if done {
					stepLogger.Info("Step is already done, skipping.")
					continue
				}
				
				// 2. 执行步骤
				stepLogger.Info("Running step")
				if err := s.Run(hostCtx); err != nil {
					err = fmt.Errorf("step '%s' failed on host '%s': %w", s.Name(), currentHost.Name, err)
					stepLogger.Error(err)
					return err
				}
			}
			return nil
		})
	}

	return g.Wait()
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **业务 Task 的组装示例**

现在，我们将使用之前设计的丰富的 Step 库，来组装一些具体、有意义的 Task。这些 Task 通常通过工厂函数创建，以便传入配置。

### **示例 1: pkg/preflight/tasks.go - 系统预检任务**

`package preflight

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/step"
"github.com/kubexms/kubexms/pkg/step/preflight" // 引入预检专用的 Step
"github.com/kubexms/kubexms/pkg/task"
)

// NewSystemChecksTask 创建一个执行一系列系统预检的 Task。
func NewSystemChecksTask(cfg *config.Cluster) *task.Task {
return &task.Task{
Name:       "Run System Preflight Checks",
RunOnRoles: []string{}, // 在所有主机上运行
Steps: []step.Step{
&preflight.CheckOSVersionStep{
SupportedOS: map[string][]string{
"ubuntu": {"20.04", "22.04"},
"centos": {"7"},
},
},
&preflight.CheckCPUStep{MinCores: 2},
&preflight.CheckMemoryStep{MinMemoryMB: 2048},
&preflight.CheckFirewallStep{},
&preflight.DisableSwapStep{},
},
}
}

// NewSetupKernelTask 创建一个配置内核参数和模块的 Task。
func NewSetupKernelTask(cfg *config.Cluster) *task.Task {
return &task.Task{
Name: "Setup Kernel Parameters and Modules",
RunOnRoles: []string{},
Steps: []step.Step{
&preflight.LoadKernelModulesStep{
Modules: []string{"br_netfilter", "overlay"},
},
&preflight.SetSystemConfigStep{
Params: map[string]string{
"net.bridge.bridge-nf-call-iptables":  "1",
"net.ipv4.ip_forward":                 "1",
"net.bridge.bridge-nf-call-ip6tables": "1",
},
},
},
}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **示例 2: pkg/containerd/tasks.go - 安装 Containerd 任务**

`package containerd

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/step"
"github.com/kubexms/kubexms/pkg/step/containerd" // 引入 containerd 专用 Step
"github.com/kubexms/kubexms/pkg/task"
)

// NewInstallContainerdTask 创建一个安装并配置 containerd 的 Task。
func NewInstallContainerdTask(cfg *config.Cluster) *task.Task {
return &task.Task{
Name:       "Install and Configure Containerd",
RunOnRoles: []string{}, // 在所有主机上运行
Steps: []step.Step{
&containerd.InstallContainerdStep{},
&containerd.ConfigureContainerdMirrorStep{
RegistryMirrors: cfg.Spec.Containerd.RegistryMirrors,
},
&containerd.ConfigureContainerdCgroupStep{},
&containerd.EnableAndStartContainerdStep{},
},
}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **示例 3: pkg/etcd/tasks.go - 在第一个 Master 节点上安装 Etcd**

这个任务展示了如何编排更复杂的、依赖于其他 Step 结果的流程。

`package etcd

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/runtime"
"github.com/kubexms/kubexms/pkg/step"
"github.com/kubexms/kubexms/pkg/step/etcd"
"github.com/kubexms/kubexms/pkg/step/pki"
"github.com/kubexms/kubexms/pkg/task"
)

// NewSetupInitialEtcdTask 创建一个在第一个主节点上安装、配置并启动 etcd 的 Task。
func NewSetupInitialEtcdTask(cfg *config.Cluster) *task.Task {
return &task.Task{
Name: "Setup Initial Etcd Member",
// 这个 Task 只在第一个 master 节点上运行
Filter: func(host *runtime.Host) bool {
// 假设第一个 master 节点的 Name 是在配置中指定的
return host.Name == cfg.Spec.Cluster.FirstMasterName
},
Steps: []step.Step{
// 安装二进制文件
&etcd.InstallEtcdBinariesStep{Version: cfg.Spec.Etcd.Version},

			// 生成所有证书
			// 注意：这里将所有 etcd 节点信息传入，以便生成正确的 SANs
			&pki.GenerateEtcdCertsStep{EtcdNodes: cfg.Spec.Etcd.Nodes},
			
			// 分发证书 (对于第一个节点，源和目标是同一台主机)
			&pki.DistributeCertsStep{
				SourceHostIsSelf: true, // 一个标志，表示从本机获取
				CertNames:       []string{"ca.crt", "server.crt", "server.key", "peer.crt", "peer.key"},
				DestinationDir:  "/etc/kubernetes/pki/etcd",
			},

			// 配置并启动服务
			&etcd.ConfigureEtcdServiceStep{
				// 从 cfg 中获取所有 etcd 节点信息来构建 --initial-cluster
				InitialCluster: buildInitialClusterString(cfg),
				State:          "new",
			},
			&etcd.EnableAndStartEtcdStep{},
			
			// 检查健康状况
			&etcd.CheckEtcdHealthStep{},
		},
	}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

**注意**: pki.DistributeCertsStep 在这里需要一些额外的逻辑来处理“源和目标是同一台主机”的情况。这可以通过增加一个 SourceHostIsSelf 字段，或者在 Run 方法中判断 ctx.Host.Name == s.SourceHost.Name 来实现。

---

### **总结：第五部分**

Task 层是连接“做什么”（Step）和“为什么做”（Module）的关键桥梁。

1. **编排与组合**: Task 的核心价值在于将低级的、原子性的 Step 组合成一个有意义的功能单元。
2. **声明式流程**: Task 的定义就像一个清晰的安装脚本，易于阅读和维护。
3. **驱动执行**: 每个 Task 都内聚了驱动其内部 Step 并发执行的逻辑，符合我们“逐层驱动”的模型。
4. **业务逻辑的载体**: 具体的业务逻辑（如应该安装哪个版本的 etcd，配置什么样的镜像）通过工厂函数的参数（cfg *config.Cluster）被注入到 Task 和它包含的 Step 中。

现在我们已经学会了如何创建 Task，下一步就是将这些 Task 进一步组装成更高层次的 Module，来管理一个完整软件组件的生命周期。