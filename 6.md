# 2-6

好的，我们已经成功地将原子性的 Step 组装成了功能性的 Task。现在，我们将迈向更高层次的抽象——Module 层。

---

### **Part 6: pkg/module - 功能模块层 (最终完整版)**

Module 的核心职责是**“管理一个完整软件组件的生命周期”**。它通过**编排相关的 Task** 来实现这一目标。例如，EtcdModule 会包含安装、配置、加入新成员、卸载 etcd 等所有相关的 Task。Module 是用户在配置文件中直接感知的、可开启或关闭的主要功能单元。

### **设计哲学**

1. **高内聚 (High Cohesion)**: 一个 Module 应该包含与单个软件组件或一个完整功能领域相关的所有 Task。例如，所有与 etcd 相关的 Task 都应该在 EtcdModule 中。
2. **生命周期管理 (Lifecycle Management)**: Module 不仅仅是 Task 的简单列表，它应该能体现一个组件的完整生命周期。虽然我们的 Run 方法主要体现了“安装/创建”这个生命周期，但通过不同的 Pipeline（如 UpgradePipeline, UninstallPipeline），可以调用同一个 Module 的不同 Task 组合来完成升级或卸载。
3. **可配置与可插拔 (Configurable & Pluggable)**: 每个 Module 都应该是可插拔的。通过 IsEnabled 函数，框架可以根据用户配置动态地决定是否执行某个模块。这使得 kubexms 可以轻松支持不同的组件选项（例如，用户可以选择 ContainerdModule 或 DockerModule）。
4. **封装决策逻辑 (Encapsulating Decision Logic)**: Module 是决定“在什么条件下，执行哪些 Task”的地方。它负责解析用户配置，并据此创建和组装正确的 Task 列表。

### **包结构 pkg/module**

与 Task 类似，Module 的具体实现也应该与其管理的业务组件放在一起。

`pkg/
├── etcd/
│   ├── module.go      # 定义 EtcdModule 的工厂函数
│   └── tasks.go       # (之前已定义)
├── kubernetes/
│   ├── module.go
│   └── tasks.go
└── containerd/
├── module.go
└── tasks.go`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

顶层的 pkg/module 包则定义 Module 的核心结构体和 Run 方法。

---

### **文件 pkg/module/module.go - 核心结构与 Run 方法**

(此部分设计在之前的“逐层驱动模型”中已非常完善，这里是它的最终版本)

`package module

import (
"context"
"fmt"
"github.com/kubexms/kubexms/pkg/runtime"
"github.com/kubexms/kubexms/pkg/task"
)

// Module 是一组高内聚的相关 Task 的集合，用于管理一个完整的软件组件。
type Module struct {
Name      string
Tasks     []*task.Task
IsEnabled func(clusterCfg interface{}) bool// 钩子可以在 Module 级别定义，并在其 Run 方法中被调用。
PreRun    func(cluster *runtime.ClusterRuntime) error
PostRun   func(cluster *runtime.ClusterRuntime, moduleErr error) error
}

// Run 是 Module 的核心方法。它按顺序驱动其内部所有 Task 的执行。
func (m *Module) Run(goCtx context.Context, cluster *runtime.ClusterRuntime) error {
moduleLogger := cluster.Logger.Sugar().With("module", m.Name)
moduleLogger.Info("Running module")

	if m.PreRun != nil {
		moduleLogger.Info("Executing PreRun hook")
		if err := m.PreRun(cluster); err != nil {
			return fmt.Errorf("module '%s' PreRun hook failed: %w", m.Name, err)
		}
	}

	var moduleErr error
	for _, t := range m.Tasks {
		// 调用 selectHostsForTask 来获取当前 Task 的目标主机
		targetHosts := selectHostsForTask(cluster, t)
		
		// 调用 Task 的 Run 方法
		taskErr := t.Run(goCtx, targetHosts, cluster)
		if taskErr != nil {
			moduleLogger.Error("Task failed", "task", t.Name, "error", taskErr)
			if !t.IgnoreError {
				moduleErr = taskErr
				break // 如果任务失败且不能忽略，则中止本模块后续任务
			}
		}
	}
	
	if m.PostRun != nil {
		moduleLogger.Info("Executing PostRun hook")
		if err := m.PostRun(cluster, moduleErr); err != nil {
			// PostRun 钩子失败通常不应覆盖主逻辑的错误，但需要记录
			moduleLogger.Error("PostRun hook failed", "error", err)
		}
	}
	
	return moduleErr
}

// selectHostsForTask 根据 Task 的规则从 ClusterRuntime 中筛选出目标主机。
func selectHostsForTask(cluster *runtime.ClusterRuntime, t *task.Task) []*runtime.Host {
var selected []*runtime.Host

	for _, host := range cluster.Hosts {
		// 阶段一: 角色匹配
		matchRole := false
		// 如果 Task 没有指定任何角色，则默认匹配所有主机
		if len(t.RunOnRoles) == 0 {
			matchRole = true
		} else {
			for _, role := range t.RunOnRoles {
				if host.Roles[role] {
					matchRole = true
					break
				}
			}
		}

		if !matchRole {
			continue
		}

		// 阶段二: 自定义过滤器匹配
		matchFilter := true
		if t.Filter != nil {
			matchFilter = t.Filter(host)
		}

		if matchFilter {
			selected = append(selected, host)
		}
	}
	return selected
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **业务 Module 的组装示例**

Module 的核心是其工厂函数，它接收全局配置，并负责创建和组装所有必要的 Task。

### **示例 1: pkg/preflight/module.go - 预检模块**

`package preflight

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/module"
"github.com/kubexms/kubexms/pkg/task"
)

// NewPreflightModule 创建一个预检模块。
func NewPreflightModule(cfg *config.Cluster) *module.Module {
return &module.Module{
Name: "Preflight Checks and Setup",
// IsEnabled 总是返回 true，因为预检是必须的
IsEnabled: func(clusterCfg interface{}) bool {
return true
},
Tasks: []*task.Task{
// 调用 preflight 包中定义的 Task 工厂函数
NewSystemChecksTask(cfg),
NewSetupKernelTask(cfg),
},
}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **示例 2: pkg/etcd/module.go - Etcd 模块**

这个例子展示了一个更复杂的 Module，它需要根据集群的节点数量来决定执行哪些 Task。

`package etcd

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/module"
"github.com/kubexms/kubexms/pkg/task"
)

// NewEtcdModule 创建 Etcd 模块。
// 它负责决策是部署单节点 etcd 还是集群 etcd。
func NewEtcdModule(cfg *config.Cluster) *module.Module {
// 决策逻辑：根据用户配置中的 etcd 节点数量，组装不同的 Task 列表。
var etcdTasks []*task.Task

	// 任务1: 在第一个主节点上安装并启动 etcd
	etcdTasks = append(etcdTasks, NewSetupInitialEtcdTask(cfg))

	// 任务2: 如果有多个 etcd 节点，则将其他节点加入集群
	if len(cfg.Spec.Etcd.Nodes) > 1 {
		etcdTasks = append(etcdTasks, NewJoinEtcdMembersTask(cfg))
	}

	return &module.Module{
		Name: "Etcd Cluster",
		// 根据用户的 etcd 配置决定是否启用此模块
		IsEnabled: func(clusterCfg interface{}) bool {
			c := clusterCfg.(*config.Cluster)
			return c.Spec.Etcd.DeployMethod == "kubexms" // 假设有此配置项
		},
		Tasks: etcdTasks,
		PreRun: func(cluster *runtime.ClusterRuntime) error {
			// 模块级别的钩子：在开始安装 etcd 之前，可以在这里执行一些全局检查，
			// 比如检查所有 etcd 节点的网络连通性。
			return nil
		},
	}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

*在 pkg/etcd/tasks.go 中，我们还需要定义 NewJoinEtcdMembersTask*:

`// pkg/etcd/tasks.go
func NewJoinEtcdMembersTask(cfg *config.Cluster) *task.Task {
return &task.Task{
Name: "Join Other Etcd Members to Cluster",
// 这个 Task 在除了第一个 master 之外的所有 etcd 节点上运行
Filter: func(host *runtime.Host) bool {
isEtcdNode := host.Roles["etcd"]
isNotFirstMaster := host.Name != cfg.Spec.Cluster.FirstMasterName
return isEtcdNode && isNotFirstMaster
},
Steps: []step.Step{
&etcd.InstallEtcdBinariesStep{...},
&pki.DistributeCertsStep{
SourceHostName: cfg.Spec.Cluster.FirstMasterName,
// ...
},
&etcd.JoinEtcdMemberStep{...},
},
}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **示例 3: pkg/kubernetes/module.go - Kubernetes 控制平面模块**

`package kubernetes

import (
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/module"
"github.com/kubexms/kubexms/pkg/task"
)

// NewControlPlaneModule 创建 Kubernetes 控制平面模块。
func NewControlPlaneModule(cfg *config.Cluster) *module.Module {
return &module.Module{
Name: "Kubernetes Control Plane",
IsEnabled: func(clusterCfg interface{}) bool { return true },
Tasks: []*task.Task{
// 1. 在所有 master 节点上安装二进制文件
NewInstallKubeBinariesTask(cfg, "master"),

			// 2. 在所有 master 节点上配置 kubelet
			NewConfigureKubeletTask(cfg, "master"),

			// 3. 在第一个 master 节点上初始化控制平面
			NewBootstrapControlPlaneTask(cfg),
			
			// 4. 将其他 master 节点加入控制平面 (HA)
			NewJoinControlPlaneTask(cfg),
			
			// 5. 在所有 master 节点上安装 CNI 插件 (通常只需要一次)
			NewInstallNetworkPluginTask(cfg),
		},
	}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **总结：第六部分**

Module 层是 kubexms 架构中承上启下的关键。

1. **封装业务决策**: Module 的工厂函数是封装“业务决策”的最佳场所。它根据用户配置，动态地决定需要执行哪些 Task，以及如何配置它们。
2. **管理组件生命周期**: 通过组合不同的 Task，Module 能够完整地表达一个软件组件的安装、配置和维护流程。
3. **提供可插拔性**: IsEnabled 函数使得整个框架的组件体系变得灵活可控，用户可以按需组合。
4. **承载更高层级的钩子**: Module 级别的钩子允许我们在一个完整组件安装前后执行一些全局性的操作，如健康检查、数据备份等。

现在，我们已经构建了功能强大的 Module。最后一步，就是将这些模块化的“功能单元”串联起来，形成一个完整的端到端工作流——Pipeline。