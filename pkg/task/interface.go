package task

import (
	"github.com/mensylisir/kubexm/pkg/plan" // Will be used for plan.NodeID, plan.ExecutionNode
	"github.com/mensylisir/kubexm/pkg/runtime"
)

// ExecutionFragment represents a piece of the total execution graph,
// generated by a single task.
type ExecutionFragment struct {
	// Nodes contains all the execution nodes for this task.
	Nodes map[plan.NodeID]*plan.ExecutionNode

	// EntryNodes are the IDs of nodes in this fragment that have no dependencies within the fragment.
	// The module layer will link dependencies TO these nodes.
	EntryNodes []plan.NodeID

	// ExitNodes are the IDs of nodes in this fragment that are not depended upon by any other node within the fragment.
	// The module layer will link dependencies FROM these nodes.
	ExitNodes []plan.NodeID
}

// NewEmptyFragment creates an empty execution fragment.
// Useful for tasks that determine no work needs to be done.
func NewEmptyFragment() *ExecutionFragment {
	return &ExecutionFragment{
		Nodes:      make(map[plan.NodeID]*plan.ExecutionNode),
		EntryNodes: []plan.NodeID{},
		ExitNodes:  []plan.NodeID{},
	}
}

// UniqueNodeIDs returns a slice with unique NodeIDs from the input.
// Preserves order of first appearance.
func UniqueNodeIDs(ids []plan.NodeID) []plan.NodeID {
	if len(ids) == 0 {
		return []plan.NodeID{}
	}
	seen := make(map[plan.NodeID]bool)
	result := []plan.NodeID{}
	for _, id := range ids {
		if !seen[id] {
			seen[id] = true
			result = append(result, id)
		}
	}
	return result
}

// Task defines the methods that all concrete task types must implement.
// Tasks are responsible for planning a subgraph of operations (ExecutionFragment)
// to achieve a specific part of a module's goal.
type Task interface {
	// Name returns the designated name of the task.
	Name() string

	// Description provides a brief summary of what the task does.
	// This can be removed if not strictly needed by the new model,
	// or kept for informational purposes. For now, I'll keep it.
	Description() string

	// IsRequired determines if the task needs to generate a plan.
	// This can be based on the current system state (via TaskContext)
	// or configuration.
	IsRequired(ctx runtime.TaskContext) (bool, error)

	// Plan now generates an ExecutionFragment, a self-contained subgraph
	// with defined entry and exit points for linking.
	Plan(ctx runtime.TaskContext) (*ExecutionFragment, error)
}
