package task

import (
	"github.com/mensylisir/kubexm/pkg/plan" // Will be used for plan.NodeID, plan.ExecutionNode
	"github.com/mensylisir/kubexm/pkg/runtime"
)

// ExecutionFragment represents a piece of the total execution graph,
// generated by a single task.
type ExecutionFragment struct {
	// Nodes contains all the execution nodes for this task.
	Nodes map[plan.NodeID]*plan.ExecutionNode

	// EntryNodes are the IDs of nodes in this fragment that have no dependencies within the fragment.
	// The module layer will link dependencies TO these nodes.
	EntryNodes []plan.NodeID

	// ExitNodes are the IDs of nodes in this fragment that are not depended upon by any other node within the fragment.
	// The module layer will link dependencies FROM these nodes.
	ExitNodes []plan.NodeID
}

// Task defines the methods that all concrete task types must implement.
// Tasks are responsible for planning a subgraph of operations (ExecutionFragment)
// to achieve a specific part of a module's goal.
type Task interface {
	// Name returns the designated name of the task.
	Name() string

	// Description provides a brief summary of what the task does.
	// This can be removed if not strictly needed by the new model,
	// or kept for informational purposes. For now, I'll keep it.
	Description() string

	// IsRequired determines if the task needs to generate a plan.
	// This can be based on the current system state (via TaskContext)
	// or configuration.
	IsRequired(ctx runtime.TaskContext) (bool, error)

	// Plan now generates an ExecutionFragment, a self-contained subgraph
	// with defined entry and exit points for linking.
	Plan(ctx runtime.TaskContext) (*ExecutionFragment, error)
}
