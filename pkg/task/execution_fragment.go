package task

import (
	"fmt"
	"github.com/mensylisir/kubexm/pkg/plan"
)

// ExecutionFragment represents a piece of the total execution graph,
// typically generated by a single task or module. It defines a self-contained
// subgraph with its own nodes, and explicit entry and exit points which
// allow it to be linked with other fragments.
type ExecutionFragment struct {
	// Nodes contains all the execution nodes that make up this fragment.
	// The keys are NodeIDs, and values are the ExecutionNode definitions.
	Nodes map[plan.NodeID]*plan.ExecutionNode

	// EntryNodes lists the IDs of nodes within this fragment that have no
	// dependencies on other nodes *within this fragment*. These are the
	// potential starting points of this fragment. When fragments are linked,
	// dependencies from preceding fragments/nodes will typically point TO these EntryNodes.
	EntryNodes []plan.NodeID

	// ExitNodes lists the IDs of nodes within this fragment that are not
	// depended upon by any other node *within this fragment*. These are the
	// potential ending points of this fragment. When fragments are linked,
	// dependencies to subsequent fragments/nodes will typically originate FROM these ExitNodes.
	ExitNodes []plan.NodeID

	// Name is an optional descriptive name for the fragment, useful for debugging.
	Name string
}

// NewExecutionFragment creates and initializes a new ExecutionFragment.
func NewExecutionFragment(name string) *ExecutionFragment {
	return &ExecutionFragment{
		Name:       name,
		Nodes:      make(map[plan.NodeID]*plan.ExecutionNode),
		EntryNodes: make([]plan.NodeID, 0),
		ExitNodes:  make([]plan.NodeID, 0),
	}
}

// AddNode adds an ExecutionNode to the fragment.
// If an ID is provided, it's used; otherwise, node.Name is used as NodeID.
func (ef *ExecutionFragment) AddNode(node *plan.ExecutionNode, id ...plan.NodeID) (plan.NodeID, error) {
	var nodeID plan.NodeID
	if len(id) > 0 {
		nodeID = id[0]
	} else {
		if node.Name == "" {
			return "", fmt.Errorf("cannot add node to fragment %s: node name is empty and no ID provided", ef.Name)
		}
		nodeID = plan.NodeID(node.Name) // Use node's descriptive name as ID if not specified
	}

	if _, exists := ef.Nodes[nodeID]; exists {
		return "", fmt.Errorf("cannot add node to fragment %s: node with ID '%s' already exists", ef.Name, nodeID)
	}
	if node == nil {
		return "", fmt.Errorf("cannot add nil node with ID '%s' to fragment %s", nodeID, ef.Name)
	}
	ef.Nodes[nodeID] = node
	return nodeID, nil
}

// AddDependency adds a dependency between two nodes within the fragment.
func (ef *ExecutionFragment) AddDependency(fromNoAddeID plan.NodeID, toNodeID plan.NodeID) error {
	if fromNodeID == toNodeID {
		return fmt.Errorf("cannot add self-dependency for node ID '%s' in fragment %s", fromNodeID, ef.Name)
	}

	sourceNode, ok := ef.Nodes[fromNodeID]
	if !ok {
		return fmt.Errorf("source node '%s' not found in fragment '%s' when adding dependency", fromNodeID, ef.Name)
	}

	targetNode, ok := ef.Nodes[toNodeID]
	if !ok {
		return fmt.Errorf("target node '%s' not found in fragment '%s' when adding dependency", toNodeID, ef.Name)
	}

	// Check for duplicate dependency
	for _, depID := range targetNode.Dependencies {
		if depID == fromNodeID {
			return nil // Dependency already exists
		}
	}
	targetNode.Dependencies = append(targetNode.Dependencies, fromNodeID)
	return nil
}


// CalculateEntryAndExitNodes analyzes the fragment's nodes and their dependencies
// to populate the EntryNodes and ExitNodes fields.
// This should be called after all nodes and internal dependencies within the fragment are set.
func (ef *ExecutionFragment) CalculateEntryAndExitNodes() {
	ef.EntryNodes = make([]plan.NodeID, 0)
	ef.ExitNodes = make([]plan.NodeID, 0)

	if len(ef.Nodes) == 0 {
		return
	}

	allNodeIDsInFragment := make(map[plan.NodeID]bool)
	hasIncomingDepInFragment := make(map[plan.NodeID]bool)
	hasOutgoingDepInFragment := make(map[plan.NodeID]bool)

	for id := range ef.Nodes {
		allNodeIDsInFragment[id] = true
		// Initialize maps
		hasIncomingDepInFragment[id] = false
		hasOutgoingDepInFragment[id] = false
	}

	for id, node := range ef.Nodes {
		if len(node.Dependencies) > 0 {
			hasIncomingDepInFragment[id] = true
		}
		for _, depID := range node.Dependencies {
			// Ensure the dependency is also within this fragment for this calculation
			if _, existsInFragment := ef.Nodes[depID]; existsInFragment {
				hasOutgoingDepInFragment[depID] = true
			}
			// If depID is not in ef.Nodes, it's an external dependency,
			// meaning 'id' is an entry point relative to that external dep,
			// but for fragment-internal calculation, we only care about internal edges.
		}
	}

	// Corrected logic for Entry/Exit nodes based on dependencies *within* the fragment
	// Re-iterate to establish outgoing dependencies based on who depends on whom *within the fragment*

	// Reset for clarity before recalculating outgoing dependencies based on actual edges
	for id := range hasOutgoingDepInFragment {
		hasOutgoingDepInFragment[id] = false
	}

	for _, node := range ef.Nodes {
		for _, depID := range node.Dependencies {
			// If 'depID' is a node within this fragment, then 'depID' has an outgoing edge to 'node'.
			if _, exists := ef.Nodes[depID]; exists {
				hasOutgoingDepInFragment[depID] = true
			}
		}
	}


	for id := range allNodeIDsInFragment {
		isEntry := true
		for _, depID := range ef.Nodes[id].Dependencies {
			if _, existsInFragment := ef.Nodes[depID]; existsInFragment {
				isEntry = false // Has a dependency from within the fragment
				break
			}
		}
		if isEntry {
			ef.EntryNodes = append(ef.EntryNodes, id)
		}

		if !hasOutgoingDepInFragment[id] {
			ef.ExitNodes = append(ef.ExitNodes, id)
		}
	}

	// Ensure uniqueness
	ef.EntryNodes = plan.UniqueNodeIDs(ef.EntryNodes)
	ef.ExitNodes = plan.UniqueNodeIDs(ef.ExitNodes)
}

// MergeFragment incorporates another ExecutionFragment into this one.
// Node IDs must be unique across fragments being merged, or they will be overwritten.
// Dependencies from the other fragment are preserved.
// Entry/Exit nodes of the merged fragment are NOT automatically recalculated;
// this should be done by the caller (e.g., Module or Pipeline) after linking.
func (ef *ExecutionFragment) MergeFragment(other *ExecutionFragment) error {
	if other == nil {
		return nil // Nothing to merge
	}
	for id, node := range other.Nodes {
		if _, exists := ef.Nodes[id]; exists {
			// بسيط: If node names are not globally unique, this could be an issue.
			// A more robust merge might involve prefixing IDs from the 'other' fragment.
			// For now, direct merge/overwrite.
			// Consider logging a warning or returning an error based on policy.
			// return fmt.Errorf("node ID '%s' from fragment '%s' already exists in fragment '%s'", id, other.Name, ef.Name)
		}
		ef.Nodes[id] = node // Add/overwrite node
	}
	// Entry and Exit nodes are more complex. The caller (Module/Pipeline)
	// is responsible for linking fragments and then recalculating the new aggregate Entry/Exit nodes.
	// We don't simply append them here as that would be incorrect without proper linking.
	return nil
}
