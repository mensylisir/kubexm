package containerd

import (
	"fmt"
	"path/filepath"
	// "strings" // Not directly used in this refactored version unless for complex path manipulations
	// "time" // Not used for step.Result

	"github.com/mensylisir/kubexm/pkg/connector"
	"github.com/mensylisir/kubexm/pkg/runtime"
	"github.com/mensylisir/kubexm/pkg/spec" // Added for spec.StepMeta
	"github.com/mensylisir/kubexm/pkg/step"
	// commonstep "github.com/mensylisir/kubexm/pkg/step/common" // Not used if key is string literal
)

// InstallContainerdStepSpec installs containerd binaries and systemd unit file
// from a previously extracted archive.
type InstallContainerdStepSpec struct {
	spec.StepMeta                    `json:",inline"`
	SourceExtractedPathSharedDataKey string            `json:"sourceExtractedPathSharedDataKey,omitempty"`
	SystemdUnitFileSourceRelPath     string            `json:"systemdUnitFileSourceRelPath,omitempty"`
	SystemdUnitFileTargetPath        string            `json:"systemdUnitFileTargetPath,omitempty"`
	BinariesToCopy                   map[string]string `json:"binariesToCopy,omitempty"` // map: source_relative_path -> target_system_path
}

// NewInstallContainerdStepSpec creates a new InstallContainerdStepSpec.
// If binariesToCopy is nil or empty, default binaries will be set.
// If systemd paths are empty, defaults will be used.
func NewInstallContainerdStepSpec( // Renamed factory
	sourceExtractedPathKey string,
	binariesToCopy map[string]string,
	systemdSourceRelPath, systemdTargetPath string,
	name, description string,
) *InstallContainerdStepSpec {
	finalName := name
	if finalName == "" {
		finalName = "Install Containerd from Extracted Files"
	}
	finalDescription := description // User-provided or generated by populateDefaults if empty

	s := &InstallContainerdStepSpec{
		StepMeta: spec.StepMeta{
			Name:        finalName,
			Description: finalDescription, // May be refined by populateDefaults
		},
		SourceExtractedPathSharedDataKey: sourceExtractedPathKey,
		SystemdUnitFileSourceRelPath:     systemdSourceRelPath,
		SystemdUnitFileTargetPath:        systemdTargetPath,
		BinariesToCopy:                   binariesToCopy,
	}
	s.populateDefaults() // Call populateDefaults after struct creation
	// Update description if it was initially empty and populateDefaults set it
	if description == "" && s.StepMeta.Description == "" {
		s.StepMeta.Description = fmt.Sprintf("Installs containerd binaries and service file using extracted content from cache key '%s'.", s.SourceExtractedPathSharedDataKey)
	}
	return s
}

func (s *InstallContainerdStepSpec) populateDefaults() {
	if s.SourceExtractedPathSharedDataKey == "" {
		// Assuming DefaultExtractedPathKey is defined in commonstep or a constants package
		// For now, using a placeholder. This should be correctly referenced from commonstep.
		// If commonstep.DefaultExtractedPathKey doesn't exist, this will need adjustment.
		// Based on previous subtask, commonstep.DefaultExtractedPathKey should be available if that step was done.
		// However, the prompt used "commonstep.DefaultExtractedPathKey" for a constant that was
		// defined in extract_archive.go itself. Let's assume this key is a well-known string for now.
		// Use the default key from ExtractContainerdStepSpec output
		s.SourceExtractedPathSharedDataKey = DefaultContainerdExtractedPathKey // "ContainerdExtractedPath"
	}
	if s.SystemdUnitFileSourceRelPath == "" {
		// Path relative to the root of extracted archive (e.g. /tmp/extract_XYZ)
		// For cri-containerd-cni*.tar.gz, this is typically etc/systemd/system/containerd.service
		s.SystemdUnitFileSourceRelPath = "etc/systemd/system/containerd.service"
	}
	if s.SystemdUnitFileTargetPath == "" {
		// Standard system path for systemd unit files
		s.SystemdUnitFileTargetPath = "/etc/systemd/system/containerd.service"
	}
	if len(s.BinariesToCopy) == 0 {
		// Source paths are relative to the root of the extracted archive.
		// Target paths are absolute system paths.
		// Based on typical cri-containerd-cni*.tar.gz structure.
		s.BinariesToCopy = map[string]string{
			"usr/local/bin/containerd":                "/usr/local/bin/containerd",
			"usr/local/bin/containerd-shim":           "/usr/local/bin/containerd-shim",
			"usr/local/bin/containerd-shim-runc-v1":   "/usr/local/bin/containerd-shim-runc-v1",
			"usr/local/bin/containerd-shim-runc-v2":   "/usr/local/bin/containerd-shim-runc-v2",
			"usr/local/bin/ctr":                       "/usr/local/bin/ctr",
			"usr/local/sbin/runc":                     "/usr/local/sbin/runc",
			// crictl might also be in usr/local/bin/crictl in some bundles
		}
	}
	// If description was not provided to factory, set a default one now that paths are populated.
	if s.StepMeta.Description == "" {
		s.StepMeta.Description = fmt.Sprintf("Installs containerd binaries and service file using extracted content from cache key '%s'. Target service file: %s",
			s.SourceExtractedPathSharedDataKey, s.SystemdUnitFileTargetPath)
	}
}

// Name returns the step's name (implementing step.Step).
func (s *InstallContainerdStepSpec) Name() string { return s.StepMeta.Name }

// Description returns the step's description (implementing step.Step).
func (s *InstallContainerdStepSpec) Description() string { return s.StepMeta.Description }

// GetName returns the step's name for spec interface.
func (s *InstallContainerdStepSpec) GetName() string { return s.StepMeta.Name }

// GetDescription returns the step's description for spec interface.
func (s *InstallContainerdStepSpec) GetDescription() string { return s.StepMeta.Description }

// GetSpec returns the spec itself.
func (s *InstallContainerdStepSpec) GetSpec() interface{} { return s }

// Meta returns the step's metadata.
func (s *InstallContainerdStepSpec) Meta() *spec.StepMeta { return &s.StepMeta }

func (s *InstallContainerdStepSpec) Precheck(ctx runtime.StepContext, host connector.Host) (bool, error) {
	logger := ctx.GetLogger().With("step", s.GetName(), "host", host.GetName(), "phase", "Precheck")
	// populateDefaults is called in constructor

	conn, err := ctx.GetConnectorForHost(host)
	if err != nil {
		return false, fmt.Errorf("failed to get connector for host %s for step %s: %w", host.GetName(), s.GetName(), err)
	}

	for _, targetPath := range s.BinariesToCopy {
		exists, errExists := conn.Exists(ctx.GoContext(), targetPath)
		if errExists != nil {
			// If we can't check, assume it's not there and let Run try.
			logger.Warn("Failed to check existence of target binary, Run will attempt installation.", "path", targetPath, "error", errExists)
			return false, nil
		}
		if !exists {
			logger.Debug("Target binary does not exist.", "path", targetPath)
			return false, nil
		}
	}
	logger.Debug("All target binaries exist.")

	if s.SystemdUnitFileTargetPath != "" {
		exists, errExists := conn.Exists(ctx.GoContext(), s.SystemdUnitFileTargetPath)
		if errExists != nil {
			logger.Warn("Failed to check existence of systemd unit file, Run will attempt installation.", "path", s.SystemdUnitFileTargetPath, "error", errExists)
			return false, nil
		}
		if !exists {
			logger.Debug("Systemd unit file does not exist.", "path", s.SystemdUnitFileTargetPath)
			return false, nil
		}
		logger.Debug("Systemd unit file exists.", "path", s.SystemdUnitFileTargetPath)
	}

	logger.Info("Containerd installation (binaries and service file) appears complete.")
	return true, nil
}

func (s *InstallContainerdStepSpec) Run(ctx runtime.StepContext, host connector.Host) error {
	logger := ctx.GetLogger().With("step", s.GetName(), "host", host.GetName(), "phase", "Run")
	// populateDefaults is called in constructor

	conn, err := ctx.GetConnectorForHost(host)
	if err != nil {
		return fmt.Errorf("failed to get connector for host %s for step %s: %w", host.GetName(), s.GetName(), err)
	}

	// Resolve source extracted path from cache (StepCache -> TaskCache -> ModuleCache)
	// This logic should ideally be in a helper or directly use a specific cache.
	// For now, let's assume TaskCache as per original logic.
	extractedPathVal, found := ctx.TaskCache().Get(s.SourceExtractedPathSharedDataKey)
	if !found {
		// Fallback to StepCache if TaskCache is not the right scope for this key in a generic context
		extractedPathVal, found = ctx.StepCache().Get(s.SourceExtractedPathSharedDataKey)
		if (!found) {
			return fmt.Errorf("path to extracted containerd not found in TaskCache/StepCache using key '%s' for step %s on host %s", s.SourceExtractedPathSharedDataKey, s.GetName(), host.GetName())
		}
	}
	extractedPath, typeOk := extractedPathVal.(string)
	if !typeOk || extractedPath == "" {
		return fmt.Errorf("invalid extracted containerd path in cache (not a string or empty) for key '%s' for step %s on host %s", s.SourceExtractedPathSharedDataKey, s.GetName(), host.GetName())
	}
	logger.Info("Using extracted containerd files from.", "path", extractedPath)

	execOptsSudo := &connector.ExecOptions{Sudo: true} // Most operations here require sudo

	for srcRelPath, targetSystemPath := range s.BinariesToCopy {
		sourceBinaryPath := filepath.Join(extractedPath, srcRelPath)
		targetDir := filepath.Dir(targetSystemPath)
		binaryName := filepath.Base(targetSystemPath)

		logger.Info("Ensuring target directory exists for binary.", "path", targetDir, "binary", binaryName)
		// Assuming conn.Mkdir handles sudo if needed, or target is writable by default.
		// For system paths, sudo is likely needed for Mkdir as well.
		// Re-evaluating: Mkdir on connector might not take sudo option. Using exec for `mkdir -p` with sudo.
		mkdirCmd := fmt.Sprintf("mkdir -p %s", targetDir)
		_, stderrMkdir, errMkdir := conn.Exec(ctx.GoContext(), mkdirCmd, execOptsSudo)
		if errMkdir != nil {
			return fmt.Errorf("failed to create target directory %s for %s (stderr: %s) for step %s on host %s: %w", targetDir, binaryName, string(stderrMkdir), s.GetName(), host.GetName(), errMkdir)
		}

		srcExists, errSrcExist := conn.Exists(ctx.GoContext(), sourceBinaryPath)
		if errSrcExist != nil {
		    logger.Warn("Could not verify existence of source binary, attempting copy anyway.", "path", sourceBinaryPath, "error", errSrcExist)
		} else if !srcExists {
		    return fmt.Errorf("source binary %s not found in extracted path %s for step %s on host %s", srcRelPath, extractedPath, s.GetName(), host.GetName())
		}

		logger.Info("Copying binary.", "source", sourceBinaryPath, "destination", targetSystemPath)
		cpCmd := fmt.Sprintf("cp -fp %s %s", sourceBinaryPath, targetSystemPath)
		_, stderrCp, errCp := conn.Exec(ctx.GoContext(), cpCmd, execOptsSudo)
		if errCp != nil {
			return fmt.Errorf("failed to copy binary %s to %s (stderr: %s) for step %s on host %s: %w", sourceBinaryPath, targetSystemPath, string(stderrCp), s.GetName(), host.GetName(), errCp)
		}

		chmodCmd := fmt.Sprintf("chmod 0755 %s", targetSystemPath)
		_, stderrChmod, errChmod := conn.Exec(ctx.GoContext(), chmodCmd, execOptsSudo)
		if errChmod != nil {
			return fmt.Errorf("failed to set permissions for %s (stderr: %s) for step %s on host %s: %w", targetSystemPath, string(stderrChmod), s.GetName(), host.GetName(), errChmod)
		}
		logger.Info("Binary installed and permissions set.", "binary", binaryName, "path", targetSystemPath)
	}

	if s.SystemdUnitFileTargetPath != "" && s.SystemdUnitFileSourceRelPath != "" {
		sourceServiceFile := filepath.Join(extractedPath, s.SystemdUnitFileSourceRelPath)
		targetServiceFileDir := filepath.Dir(s.SystemdUnitFileTargetPath)

		logger.Info("Ensuring target directory for systemd unit file exists.", "path", targetServiceFileDir)
		mkdirSvcCmd := fmt.Sprintf("mkdir -p %s", targetServiceFileDir)
		_, stderrMkdirSvc, errMkdirSvc := conn.Exec(ctx.GoContext(), mkdirSvcCmd, execOptsSudo)
		if errMkdirSvc != nil {
			return fmt.Errorf("failed to create target directory %s for systemd unit file (stderr: %s) for step %s on host %s: %w", targetServiceFileDir, string(stderrMkdirSvc), s.GetName(), host.GetName(), errMkdirSvc)
		}

		srcSvcExists, errSrcSvcExist := conn.Exists(ctx.GoContext(), sourceServiceFile)
		if errSrcSvcExist != nil {
		    logger.Warn("Could not verify existence of source systemd file, attempting copy anyway.", "path", sourceServiceFile, "error", errSrcSvcExist)
		} else if !srcSvcExists {
		    logger.Warn("Source systemd unit file not found in extracted archive. Skipping installation of service file.", "sourcePath", sourceServiceFile, "archivePath", extractedPath)
		}

		if srcSvcExists {
		    logger.Info("Copying systemd unit file.", "source", sourceServiceFile, "destination", s.SystemdUnitFileTargetPath)
		    cpCmd := fmt.Sprintf("cp -f %s %s", sourceServiceFile, s.SystemdUnitFileTargetPath)
		    _, stderrCpSvc, errCpSvc := conn.Exec(ctx.GoContext(), cpCmd, execOptsSudo)
		    if errCpSvc != nil {
			return fmt.Errorf("failed to copy systemd unit file from %s to %s (stderr: %s) for step %s on host %s: %w", sourceServiceFile, s.SystemdUnitFileTargetPath, string(stderrCpSvc), s.GetName(), host.GetName(), errCpSvc)
		    }
		    chmodCmdSvc := fmt.Sprintf("chmod 0644 %s", s.SystemdUnitFileTargetPath)
		    _, stderrChmodSvc, errChmodSvc := conn.Exec(ctx.GoContext(), chmodCmdSvc, execOptsSudo)
		    if errChmodSvc != nil {
			return fmt.Errorf("failed to set permissions for systemd unit file %s (stderr: %s) for step %s on host %s: %w", s.SystemdUnitFileTargetPath, string(stderrChmodSvc), s.GetName(), host.GetName(), errChmodSvc)
		    }
		    logger.Info("Systemd unit file installed successfully.", "path", s.SystemdUnitFileTargetPath)
		}
	} else {
		logger.Info("No systemd unit file source or target path specified. Skipping systemd unit file installation.")
	}
	return nil
}

func (s *InstallContainerdStepSpec) Rollback(ctx runtime.StepContext, host connector.Host) error {
	logger := ctx.GetLogger().With("step", s.GetName(), "host", host.GetName(), "phase", "Rollback")
	// populateDefaults is called in constructor

	conn, err := ctx.GetConnectorForHost(host)
	if err != nil {
		return fmt.Errorf("failed to get connector for host %s for rollback of step %s: %w", host.GetName(), s.GetName(), err)
	}

	execOptsSudo := &connector.ExecOptions{Sudo: true}

	for _, targetPath := range s.BinariesToCopy {
		logger.Info("Attempting to remove binary for rollback.", "path", targetPath)
		rmCmd := fmt.Sprintf("rm -f %s", targetPath)
		_, stderrRm, errRm := conn.Exec(ctx.GoContext(), rmCmd, execOptsSudo)
		if errRm != nil {
			logger.Error("Failed to remove binary during rollback.", "path", targetPath, "stderr", string(stderrRm), "error", errRm)
			// Continue rollback, best-effort
		}
	}

	if s.SystemdUnitFileTargetPath != "" {
		logger.Info("Attempting to remove systemd unit file for rollback.", "path", s.SystemdUnitFileTargetPath)
		rmCmd := fmt.Sprintf("rm -f %s", s.SystemdUnitFileTargetPath)
		_, stderrRmSvc, errRmSvc := conn.Exec(ctx.GoContext(), rmCmd, execOptsSudo)
		if errRmSvc != nil {
			logger.Error("Failed to remove systemd unit file during rollback.", "path", s.SystemdUnitFileTargetPath, "stderr", string(stderrRmSvc), "error", errRmSvc)
			// Continue rollback, best-effort
		}
	}
	logger.Info("Rollback attempt for containerd installation finished.")
	return nil
}

// Ensure InstallContainerdStepSpec implements the step.Step interface.
var _ step.Step = (*InstallContainerdStepSpec)(nil)
