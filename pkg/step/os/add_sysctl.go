package os

import (
	"fmt"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/mensylisir/kubexm/pkg/common"
	"github.com/mensylisir/kubexm/pkg/runtime"
	"github.com/mensylisir/kubexm/pkg/spec"
	"github.com/mensylisir/kubexm/pkg/step"
	"github.com/pkg/errors"
)

type ConfigureSysctlStep struct {
	step.Base
	configFileCreated bool
}

type ConfigureSysctlStepBuilder struct {
	step.Builder[ConfigureSysctlStepBuilder, *ConfigureSysctlStep]
}

func NewConfigureSysctlStepBuilder(ctx runtime.Context, instanceName string) *ConfigureSysctlStepBuilder {
	s := &ConfigureSysctlStep{}

	s.Base.Meta.Name = instanceName
	s.Base.Meta.Description = fmt.Sprintf("[%s] >> Configure kernel parameters (sysctl)", s.Base.Meta.Name)
	s.Base.Sudo = false
	s.Base.IgnoreError = false
	s.Base.Timeout = 2 * time.Minute

	b := new(ConfigureSysctlStepBuilder).Init(s)
	return b
}

func (s *ConfigureSysctlStep) Meta() *spec.StepMeta {
	return &s.Base.Meta
}

func (s *ConfigureSysctlStep) generateExpectedContent(ctx runtime.ExecutionContext) (string, error) {
	cluster := ctx.GetClusterConfig()

	params := map[string]string{
		"net.ipv4.ip_forward":                 "1",
		"net.bridge.bridge-nf-call-iptables":  "1",
		"net.bridge.bridge-nf-call-ip6tables": "1",
		"net.bridge.bridge-nf-call-arptables": "1",
		"vm.swappiness":                       "0",
		"vm.max_map_count":                    "262144",
		"fs.inotify.max_user_instances":       "524288",
		"net.ipv4.ip_local_reserved_ports":    "30000-32767",
		"net.core.somaxconn":                  "32768",
		"vm.overcommit_memory":                "1",
		"fs.inotify.max_user_watches":         "10240001",
		"fs.pipe-max-size":                    "4194304",
	}

	ipv6Enabled := false
	if cluster.Spec.Network != nil && cluster.Spec.Network.KubePodsCIDR != "" {
		if len(strings.Split(cluster.Spec.Network.KubePodsCIDR, ",")) == 2 {
			ipv6Enabled = true
		}
	}

	if ipv6Enabled {
		ctx.GetLogger().With("step", s.Meta().Name).Info("IPv6 dual-stack detected, adding IPv6 sysctl parameters.")
		params["net.ipv6.conf.all.forwarding"] = "1"
		params["net.ipv6.conf.all.disable_ipv6"] = "0"
		params["net.ipv6.conf.default.disable_ipv6"] = "0"
		params["net.ipv6.conf.lo.disable_ipv6"] = "0"
		params["net.ipv6.conf.default.accept_dad"] = "0"
		params["net.ipv6.route.max_size"] = "65536"
		params["net.ipv6.neigh.default.retrans_time_ms"] = "1000"
	}

	if cluster.Spec.System != nil && cluster.Spec.System.SysctlParams != nil {
		for key, value := range cluster.Spec.System.SysctlParams {
			params[key] = value
		}
	}

	var keys []string
	for k := range params {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var builder strings.Builder
	builder.WriteString("# Generated by KubeXM for Kubernetes prerequisites\n")
	for _, key := range keys {
		builder.WriteString(fmt.Sprintf("%s = %s\n", key, params[key]))
	}

	return builder.String(), nil
}

func (s *ConfigureSysctlStep) Precheck(ctx runtime.ExecutionContext) (isDone bool, err error) {
	logger := ctx.GetLogger().With("step", s.Base.Meta.Name, "host", ctx.GetHost().GetName(), "phase", "Precheck")
	runner := ctx.GetRunner()
	conn, err := ctx.GetCurrentHostConnector()
	if err != nil {
		return false, err
	}

	expectedContent, err := s.generateExpectedContent(ctx)
	if err != nil {
		return false, errors.Wrap(err, "failed to generate expected sysctl config")
	}

	filePath := common.KubernetesSysctlConfFileTarget
	currentContentBytes, err := runner.ReadFile(ctx.GoContext(), conn, filePath)
	if err != nil {
		if os.IsNotExist(err) || strings.Contains(err.Error(), "No such file or directory") {
			logger.Infof("Sysctl config file '%s' not found, needs to be created.", filePath)
			return false, nil
		}
		return false, errors.Wrapf(err, "failed to read sysctl config file '%s'", filePath)
	}

	if strings.TrimSpace(string(currentContentBytes)) == strings.TrimSpace(expectedContent) {
		logger.Infof("Sysctl config '%s' is already up-to-date.", filePath)
		return true, nil
	}

	logger.Infof("Sysctl config '%s' needs to be updated.", filePath)
	return false, nil
}

func (s *ConfigureSysctlStep) Run(ctx runtime.ExecutionContext) error {
	logger := ctx.GetLogger().With("step", s.Base.Meta.Name, "host", ctx.GetHost().GetName(), "phase", "Run")
	runner := ctx.GetRunner()
	conn, err := ctx.GetCurrentHostConnector()
	if err != nil {
		return err
	}

	filePath := common.KubernetesSysctlConfFileTarget

	fileExists, err := runner.Exists(ctx.GoContext(), conn, filePath)
	if err != nil {
		return errors.Wrapf(err, "failed to check for existence of '%s'", filePath)
	}
	s.configFileCreated = !fileExists

	content, err := s.generateExpectedContent(ctx)
	if err != nil {
		return err
	}

	logger.Infof("Writing sysctl configuration to '%s'...", filePath)
	permissions := fmt.Sprintf("0%o", common.DefaultConfigFilePermission)
	err = runner.WriteFile(ctx.GoContext(), conn, []byte(content), filePath, permissions, s.Sudo)
	if err != nil {
		return errors.Wrapf(err, "failed to write sysctl config file '%s'", filePath)
	}

	logger.Info("Applying new sysctl settings...")
	if _, err := runner.Run(ctx.GoContext(), conn, "sysctl --system", s.Sudo); err != nil {
		return errors.Wrap(err, "failed to apply sysctl settings with 'sysctl --system'")
	}

	logger.Info("Sysctl configuration applied successfully.")
	return nil
}

func (s *ConfigureSysctlStep) Rollback(ctx runtime.ExecutionContext) error {
	logger := ctx.GetLogger().With("step", s.Base.Meta.Name, "host", ctx.GetHost().GetName(), "phase", "Rollback")
	runner := ctx.GetRunner()
	conn, err := ctx.GetCurrentHostConnector()
	if err != nil {
		return err
	}

	if s.configFileCreated {
		filePath := common.KubernetesSysctlConfFileTarget
		logger.Infof("Rolling back by removing sysctl config file '%s'...", filePath)

		if err := runner.Remove(ctx.GoContext(), conn, filePath, s.Sudo, false); err != nil {
			return errors.Wrapf(err, "failed to remove sysctl config file '%s' during rollback", filePath)
		}

		logger.Info("Re-applying system default sysctl settings...")
		if _, err := runner.Run(ctx.GoContext(), conn, "sysctl --system", s.Sudo); err != nil {
			logger.Warnf("Failed to re-apply sysctl settings during rollback. A reboot may be needed to fully revert. Error: %v", err)
		}

		logger.Infof("Sysctl configuration rolled back.")
	} else {
		logger.Info("Skipping rollback as the sysctl config file existed before this step.")
	}

	return nil
}
