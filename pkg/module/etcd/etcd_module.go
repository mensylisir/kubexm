package etcd

import (
	"fmt"

	"github.com/mensylisir/kubexm/pkg/apis/kubexms/v1alpha1"
	"github.com/mensylisir/kubexm/pkg/module"
	"github.com/mensylisir/kubexm/pkg/plan"
	"github.com/mensylisir/kubexm/pkg/runtime"
	"github.com/mensylisir/kubexm/pkg/task"
	taskEtcd "github.com/mensylisir/kubexm/pkg/task/etcd" // Renamed to avoid conflict
)

// EtcdModule manages the ETCD cluster setup.
type EtcdModule struct {
	module.BaseModule
}

// NewEtcdModule creates a new module for ETCD cluster management.
func NewEtcdModule() module.Module {
	// Instantiate tasks that this module will manage.
	// The InstallETCDTask is the primary one for setting up ETCD.
	// Other tasks like backup, restore, member management could be added here later.
	installEtcdTask := taskEtcd.NewInstallETCDTask()

	// PKI related tasks might also be part of this module or a separate PKI module.
	// For now, let's assume InstallETCDTask handles what's needed or depends on a PKI task.
	// If PKI generation is complex and separate:
	//   pkiSetupTask := taskPki.NewSetupEtcdPkiTask() // Example name
	//   allModuleTasks := []task.Task{pkiSetupTask, installEtcdTask}

	allModuleTasks := []task.Task{installEtcdTask}

	base := module.NewBaseModule("ETCDClusterManagement", allModuleTasks)
	return &EtcdModule{BaseModule: base}
}

// Plan generates the execution fragment for the ETCD module.
// It calls the Plan method of its constituent tasks and links them if necessary.
func (m *EtcdModule) Plan(ctx runtime.ModuleContext) (*task.ExecutionFragment, error) {
	logger := ctx.GetLogger().With("module", m.Name())
	clusterConfig := ctx.GetClusterConfig()

	// Module level enablement check: only proceed if ETCD is configured at all.
	// The InstallETCDTask itself will further check if it's an internal type.
	if clusterConfig.Spec.Etcd == nil {
		logger.Info("ETCD module is not required (ETCD spec is nil). Skipping.")
		return task.NewEmptyFragment(), nil
	}
	// If type is external, InstallETCDTask.IsRequired will be false.
	// We might still want to run other etcd-related tasks for external etcd (e.g., client cert setup, health checks).
	// For now, this module focuses on the `InstallETCDTask`.

	moduleFragment := task.NewExecutionFragment()
	var lastTaskExitNodes []plan.NodeID
	firstTask := true

	for _, currentTask := range m.Tasks() { // m.Tasks() comes from BaseModule
		// The ModuleContext (ctx) is passed directly.
		// If Task methods expect runtime.TaskContext, and ModuleContext is a subset (or can be
		// fulfilled by the same underlying *runtime.Context object), this direct pass is fine.
		// Based on facade design: ModuleContext is passed, method signatures for Task take TaskContext.
		// The concrete *runtime.Context implements all, so it works.

		taskIsRequired, err := currentTask.IsRequired(ctx) // Pass ModuleContext directly
		if err != nil {
			return nil, fmt.Errorf("failed to check if task %s is required in module %s: %w", currentTask.Name(), m.Name(), err)
		}

		if !taskIsRequired {
			logger.Info("Skipping task as it's not required", "task_name", currentTask.Name())
			continue
		}

		logger.Info("Planning task", "task_name", currentTask.Name())
		taskFrag, err := currentTask.Plan(ctx) // Pass ModuleContext directly
		if err != nil {
			return nil, fmt.Errorf("failed to plan task %s in module %s: %w", currentTask.Name(), m.Name(), err)
		}

		if taskFrag == nil || len(taskFrag.Nodes) == 0 {
			logger.Info("Task returned an empty fragment, skipping merge", "task_name", currentTask.Name())
			continue
		}

		// Merge nodes from task fragment into module fragment
		for id, node := range taskFrag.Nodes {
			if _, exists := moduleFragment.Nodes[id]; exists {
				// This indicates a NodeID collision, which should be avoided by design
				// (e.g., by prefixing NodeIDs with task/module names or ensuring unique step instance names).
				return nil, fmt.Errorf("duplicate NodeID '%s' generated by task '%s' in module '%s'", id, currentTask.Name(), m.Name())
			}
			moduleFragment.Nodes[id] = node
		}

		// Link current task's entry nodes to previous task's exit nodes
		if !firstTask && len(lastTaskExitNodes) > 0 {
			for _, entryNodeID := range taskFrag.EntryNodes {
				if entryNode, ok := moduleFragment.Nodes[entryNodeID]; ok {
					// Append dependencies, ensuring no duplicates if already dependent
					existingDeps := make(map[plan.NodeID]bool)
					for _, dep := range entryNode.Dependencies {
						existingDeps[dep] = true
					}
					for _, depToAdd := range lastTaskExitNodes {
						if !existingDeps[depToAdd] {
							entryNode.Dependencies = append(entryNode.Dependencies, depToAdd)
						}
					}
				} else {
					return nil, fmt.Errorf("entry node ID '%s' from task '%s' not found in module fragment", entryNodeID, currentTask.Name())
				}
			}
		} else if firstTask {
			moduleFragment.EntryNodes = append(moduleFragment.EntryNodes, taskFrag.EntryNodes...)
		}

		if len(taskFrag.ExitNodes) > 0 {
			lastTaskExitNodes = taskFrag.ExitNodes // Update for the next task
			firstTask = false
		}
	}

	// Set the module's exit nodes to be the exit nodes of the last processed task
	// (or all tasks' exit nodes if they can run in parallel and don't feed into a single module exit point)
	moduleFragment.ExitNodes = append(moduleFragment.ExitNodes, lastTaskExitNodes...)

	// Deduplicate entry and exit nodes for the final module fragment
	moduleFragment.EntryNodes = task.UniqueNodeIDs(moduleFragment.EntryNodes)
	moduleFragment.ExitNodes = task.UniqueNodeIDs(moduleFragment.ExitNodes)


	logger.Info("ETCD module planning complete.", "total_nodes", len(moduleFragment.Nodes), "entry_nodes", len(moduleFragment.EntryNodes), "exit_nodes", len(moduleFragment.ExitNodes))
	return moduleFragment, nil
}

// Ensure EtcdModule implements the module.Module interface.
var _ module.Module = (*EtcdModule)(nil)
