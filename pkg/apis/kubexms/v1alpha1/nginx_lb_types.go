package v1alpha1

import (
	"fmt"
	"net"
	"strconv"
	"strings"
	"github.com/mensylisir/kubexm/pkg/util"
	"github.com/mensylisir/kubexm/pkg/util/validation"
	"github.com/mensylisir/kubexm/pkg/common"
)

var (
	validNginxLBModes      = []string{"tcp", "http"}
	validNginxLBAlgorithms = []string{"round_robin", "least_conn", "ip_hash", "hash", "random", "least_time"}
)

// NginxLBUpstreamServer defines a backend server for Nginx load balancing.
// Address should be in "host:port" format.
type NginxLBUpstreamServer struct {
	// Address is the IP:port or resolvable hostname:port of the backend server.
	Address string `json:"address" yaml:"address"`
	// Weight for weighted load balancing algorithms (optional).
	Weight *int `json:"weight,omitempty" yaml:"weight,omitempty"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NginxLBUpstreamServer) DeepCopyInto(out *NginxLBUpstreamServer) {
	*out = *in
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(int)
		**out = *in
	}
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NginxLBConfig) DeepCopyInto(out *NginxLBConfig) {
	*out = *in
	if in.ListenAddress != nil {
		in, out := &in.ListenAddress, &out.ListenAddress
		*out = new(string)
		**out = *in
	}
	if in.ListenPort != nil {
		in, out := &in.ListenPort, &out.ListenPort
		*out = new(int)
		**out = *in
	}
	if in.Mode != nil {
		in, out := &in.Mode, &out.Mode
		*out = new(string)
		**out = *in
	}
	if in.BalanceAlgorithm != nil {
		in, out := &in.BalanceAlgorithm, &out.BalanceAlgorithm
		*out = new(string)
		**out = *in
	}
	if in.UpstreamServers != nil {
		in, out := &in.UpstreamServers, &out.UpstreamServers
		*out = make([]NginxLBUpstreamServer, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExtraHTTPConfig != nil {
		in, out := &in.ExtraHTTPConfig, &out.ExtraHTTPConfig
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExtraStreamConfig != nil {
		in, out := &in.ExtraStreamConfig, &out.ExtraStreamConfig
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExtraServerConfig != nil {
		in, out := &in.ExtraServerConfig, &out.ExtraServerConfig
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ConfigFilePath != nil {
		in, out := &in.ConfigFilePath, &out.ConfigFilePath
		*out = new(string)
		**out = *in
	}
	if in.SkipInstall != nil {
		in, out := &in.SkipInstall, &out.SkipInstall
		*out = new(bool)
		**out = *in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NginxLBConfig.
func (in *NginxLBConfig) DeepCopy() *NginxLBConfig {
	if in == nil {
		return nil
	}
	out := new(NginxLBConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NginxLBUpstreamServer.
func (in *NginxLBUpstreamServer) DeepCopy() *NginxLBUpstreamServer {
	if in == nil {
		return nil
	}
	out := new(NginxLBUpstreamServer)
	in.DeepCopyInto(out)
	return out
}

// NginxLBConfig defines settings for using Nginx as a TCP/HTTP load balancer,
// typically for services like the Kubernetes API server.
type NginxLBConfig struct {
	ListenAddress     *string                 `json:"listenAddress,omitempty" yaml:"listenAddress,omitempty"`
	ListenPort        *int                    `json:"listenPort,omitempty" yaml:"listenPort,omitempty"`
	Mode              *string                 `json:"mode,omitempty" yaml:"mode,omitempty"`
	BalanceAlgorithm  *string                 `json:"balanceAlgorithm,omitempty" yaml:"balanceAlgorithm,omitempty"`
	UpstreamServers   []NginxLBUpstreamServer `json:"upstreamServers,omitempty" yaml:"upstreamServers,omitempty"`
	ExtraHTTPConfig   []string                `json:"extraHttpConfig,omitempty" yaml:"extraHttpConfig,omitempty"`
	ExtraStreamConfig []string                `json:"extraStreamConfig,omitempty" yaml:"extraStreamConfig,omitempty"`
	ExtraServerConfig []string                `json:"extraServerConfig,omitempty" yaml:"extraServerConfig,omitempty"`
	ConfigFilePath    *string                 `json:"configFilePath,omitempty" yaml:"configFilePath,omitempty"`
	SkipInstall       *bool                   `json:"skipInstall,omitempty" yaml:"skipInstall,omitempty"`
}

// SetDefaults_NginxLBConfig sets default values for NginxLBConfig.
func SetDefaults_NginxLBConfig(cfg *NginxLBConfig) {
	if cfg == nil {
		return
	}
	if cfg.ListenAddress == nil {
		cfg.ListenAddress = util.StrPtr("0.0.0.0")
	}
	if cfg.ListenPort == nil {
		cfg.ListenPort = util.IntPtr(common.DefaultNginxListenPort) // Assuming 6443 or a specific const
	}
	if cfg.Mode == nil {
		cfg.Mode = util.StrPtr(common.DefaultNginxMode)
	}
	if cfg.BalanceAlgorithm == nil {
		cfg.BalanceAlgorithm = util.StrPtr(common.DefaultNginxAlgorithm)
	}
	if cfg.UpstreamServers == nil {
		cfg.UpstreamServers = []NginxLBUpstreamServer{}
	}
	for i := range cfg.UpstreamServers {
		server := &cfg.UpstreamServers[i]
		if server.Weight == nil {
			server.Weight = util.IntPtr(1)
		}
	}
	if cfg.ExtraHTTPConfig == nil { cfg.ExtraHTTPConfig = []string{} }
	if cfg.ExtraStreamConfig == nil { cfg.ExtraStreamConfig = []string{} }
	if cfg.ExtraServerConfig == nil { cfg.ExtraServerConfig = []string{} }
	if cfg.ConfigFilePath == nil {
		cfg.ConfigFilePath = util.StrPtr(common.DefaultNginxConfigFilePath) // Assuming "/etc/nginx/nginx.conf"
	}
	if cfg.SkipInstall == nil {
		cfg.SkipInstall = util.BoolPtr(false)
	}
}

// Validate_NginxLBConfig validates NginxLBConfig.
func Validate_NginxLBConfig(cfg *NginxLBConfig, verrs *validation.ValidationErrors, pathPrefix string) {
	if cfg == nil {
		return
	}
	if cfg.SkipInstall != nil && *cfg.SkipInstall {
		return
	}

	if cfg.ListenAddress != nil {
		if strings.TrimSpace(*cfg.ListenAddress) == "" {
			verrs.Add(pathPrefix+".listenAddress", "cannot be empty if specified")
		} else if net.ParseIP(*cfg.ListenAddress) == nil && *cfg.ListenAddress != "0.0.0.0" && *cfg.ListenAddress != "::" {
			verrs.Add(pathPrefix+".listenAddress", fmt.Sprintf("invalid IP address format '%s'", *cfg.ListenAddress))
		}
	}
	// ListenAddress can be nil, allowing Nginx to use its own default binding.

	if cfg.ListenPort == nil { // Should be set by defaults
		verrs.Add(pathPrefix+".listenPort", "is required and should have a default value")
	} else if *cfg.ListenPort <= 0 || *cfg.ListenPort > 65535 {
		verrs.Add(pathPrefix+".listenPort", fmt.Sprintf("invalid port %d", *cfg.ListenPort))
	}

	if cfg.Mode == nil { // Should be set by defaults
		verrs.Add(pathPrefix+".mode", "is required and should have a default value 'tcp'")
	} else if *cfg.Mode != "" { // Validate only if user provided a non-empty value
	   if !util.ContainsString(validNginxLBModes, *cfg.Mode) {
		   verrs.Add(pathPrefix+".mode", fmt.Sprintf("invalid mode '%s', must be one of %v", *cfg.Mode, validNginxLBModes))
	   }
	}

	if cfg.BalanceAlgorithm == nil { // Should be set by defaults
		verrs.Add(pathPrefix+".balanceAlgorithm", "is required and should have a default value 'round_robin'")
	} else if *cfg.BalanceAlgorithm != "" { // Validate only if user provided a non-empty value
		// Nginx's default is round_robin for stream, and various for http depending on context.
		// For simplicity, we list common ones. If empty, Nginx will use its internal default.
		if !util.ContainsString(validNginxLBAlgorithms, *cfg.BalanceAlgorithm) {
			verrs.Add(pathPrefix+".balanceAlgorithm", fmt.Sprintf("invalid algorithm '%s', must be one of %v or empty for Nginx default", *cfg.BalanceAlgorithm, validNginxLBAlgorithms))
		}
	}

	if len(cfg.UpstreamServers) == 0 {
		verrs.Add(pathPrefix+".upstreamServers", "must specify at least one upstream server")
	}
	for i, server := range cfg.UpstreamServers {
		serverPath := fmt.Sprintf("%s.upstreamServers[%d]", pathPrefix, i)
		if strings.TrimSpace(server.Address) == "" {
			verrs.Add(serverPath+".address", "upstream server address cannot be empty")
		} else {
			host, portStr, err := net.SplitHostPort(server.Address)
			if err != nil {
				verrs.Add(serverPath+".address", fmt.Sprintf("upstream server address '%s' must be in 'host:port' format", server.Address))
			} else {
				if strings.TrimSpace(host) == "" {
					verrs.Add(serverPath+".address", fmt.Sprintf("host part of upstream server address '%s' cannot be empty", server.Address))
				} else if !util.IsValidIP(host) && !util.IsValidDomainName(host) {
					verrs.Add(serverPath+".address", fmt.Sprintf("host part '%s' of upstream server address '%s' is not a valid host or IP", host, server.Address))
				}
				if port, errConv := strconv.Atoi(portStr); errConv != nil || port <= 0 || port > 65535 {
					verrs.Add(serverPath+".address", fmt.Sprintf("port part '%s' of upstream server address '%s' is not a valid port number", portStr, server.Address))
				}
			}
		}
		if server.Weight != nil && *server.Weight < 0 {
			verrs.Add(serverPath+".weight", fmt.Sprintf("cannot be negative, got %d", *server.Weight))
		}
	}
	if cfg.ConfigFilePath != nil && strings.TrimSpace(*cfg.ConfigFilePath) == "" {
	   verrs.Add(pathPrefix+".configFilePath", "cannot be empty if specified")
	}
}
