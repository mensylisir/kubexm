package v1alpha1

import (
	"net"
	"regexp"
	"strings"
	// Assuming ValidationErrors and containsString are defined in cluster_types.go or a shared util in this package
)

// ControlPlaneEndpointSpec defines the configuration for the cluster's control plane endpoint.
type ControlPlaneEndpointSpec struct {
	Domain                   string `json:"domain,omitempty" yaml:"domain,omitempty"`
	Address                  string `json:"address,omitempty" yaml:"lb_address,omitempty"` // Matches YAML lb_address
	Port                     int    `json:"port,omitempty" yaml:"port,omitempty"`
	ExternalDNS              bool   `json:"externalDNS,omitempty" yaml:"externalDNS,omitempty"` // Changed to bool
	ExternalLoadBalancerType string `json:"externalLoadBalancerType,omitempty" yaml:"externalLoadBalancer,omitempty"`
	InternalLoadBalancerType string `json:"internalLoadBalancerType,omitempty" yaml:"internalLoadbalancer,omitempty"` // Matches YAML internalLoadbalancer
}

// SetDefaults_ControlPlaneEndpointSpec sets default values for ControlPlaneEndpointSpec.
func SetDefaults_ControlPlaneEndpointSpec(cfg *ControlPlaneEndpointSpec) {
	if cfg == nil {
		return
	}
	if cfg.Port == 0 {
		cfg.Port = 6443
	}
	// ExternalDNS (bool) defaults to false (its zero value).
}

// Validate_ControlPlaneEndpointSpec validates ControlPlaneEndpointSpec.
func Validate_ControlPlaneEndpointSpec(cfg *ControlPlaneEndpointSpec, verrs *ValidationErrors, pathPrefix string) {
	if cfg == nil {
		// If this section is optional and not provided, it's valid.
		// If it's mandatory, the caller (e.g. Validate_ClusterSpec) should check for nil.
		return
	}
	if strings.TrimSpace(cfg.Domain) == "" && strings.TrimSpace(cfg.Address) == "" {
		verrs.Add("%s: either domain or address (lb_address in YAML) must be specified", pathPrefix)
	}
	if cfg.Domain != "" {
		// Standard domain validation regex
		if matched, _ := regexp.MatchString(`^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$`, cfg.Domain); !matched {
			verrs.Add("%s.domain: '%s' is not a valid domain name", pathPrefix, cfg.Domain)
		}
	}
	if cfg.Address != "" && !isValidIP(cfg.Address) { // Assuming isValidIP is available
		verrs.Add("%s.address (lb_address): invalid IP address format for '%s'", pathPrefix, cfg.Address)
	}

	if cfg.Port != 0 && (cfg.Port <= 0 || cfg.Port > 65535) { // Port 0 is defaulted
		verrs.Add("%s.port: invalid port %d, must be between 1-65535", pathPrefix, cfg.Port)
	}

	validExternalTypes := []string{"kubexm", "external", ""} // "" means not specified/use default or inferred
	if !containsString(validExternalTypes, cfg.ExternalLoadBalancerType) { // Assuming containsString is available
		verrs.Add("%s.externalLoadBalancerType: invalid type '%s', must be one of %v or empty", pathPrefix, cfg.ExternalLoadBalancerType, validExternalTypes)
	}

	validInternalTypes := []string{"haproxy", "nginx", "kube-vip", ""} // "" means not specified/use default or inferred
	if !containsString(validInternalTypes, cfg.InternalLoadBalancerType) {
		verrs.Add("%s.internalLoadBalancerType (internalLoadbalancer): invalid type '%s', must be one of %v or empty", pathPrefix, cfg.InternalLoadBalancerType, validInternalTypes)
	}
}

// isValidIP and containsString are expected to be defined in cluster_types.go or a shared util.
// For self-containedness, if they were local:
// func isValidIP(ip string) bool { return net.ParseIP(ip) != nil }
// func containsString(slice []string, item string) bool { for _, s := range slice { if s == item { return true } }; return false }
// NOTE: DeepCopy methods should be generated by controller-gen.
// Changed ExternalDNS to bool from *bool as per latest interpretation of the prompt.
// Updated YAML tags to match prompt: lb_address, externalLoadBalancer, internalLoadbalancer.
// Imported "net" and "regexp".
// Assumed ValidationErrors is defined in cluster_types.go.
// Added containsString from cluster_types.go (if it's not there, it needs to be added or imported).
// Added isValidIP from cluster_types.go (if it's not there, it needs to be added or imported).
