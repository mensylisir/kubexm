package v1alpha1

import (
	"fmt"
	"regexp"
	"strings"
	// ValidationErrors is defined in cluster_types.go
)

// ControlPlaneEndpointSpec defines the configuration for the cluster's control plane endpoint.
type ControlPlaneEndpointSpec struct {
	Domain                   string `json:"domain,omitempty" yaml:"domain,omitempty"`
	Address                  string `json:"address,omitempty" yaml:"lb_address,omitempty"` // Matches YAML lb_address
	Port                     int    `json:"port,omitempty" yaml:"port,omitempty"`
	ExternalDNS              bool   `json:"externalDNS,omitempty" yaml:"externalDNS,omitempty"` // Changed to bool
	ExternalLoadBalancerType string `json:"externalLoadBalancerType,omitempty" yaml:"externalLoadBalancer,omitempty"`
	InternalLoadBalancerType string `json:"internalLoadBalancerType,omitempty" yaml:"internalLoadbalancer,omitempty"` // Matches YAML internalLoadbalancer
}

// SetDefaults_ControlPlaneEndpointSpec sets default values for ControlPlaneEndpointSpec.
func SetDefaults_ControlPlaneEndpointSpec(cfg *ControlPlaneEndpointSpec) {
	if cfg == nil {
		return
	}
	if cfg.Port == 0 {
		cfg.Port = 6443
	}
	// ExternalDNS (bool) defaults to false (its zero value).
}

// Validate_ControlPlaneEndpointSpec validates ControlPlaneEndpointSpec.
func Validate_ControlPlaneEndpointSpec(cfg *ControlPlaneEndpointSpec, verrs *ValidationErrors, pathPrefix string) {
	if cfg == nil {
		// If this section is optional and not provided, it's valid.
		// If it's mandatory, the caller (e.g. Validate_ClusterSpec) should check for nil.
		return
	}
	if strings.TrimSpace(cfg.Domain) == "" && strings.TrimSpace(cfg.Address) == "" {
		verrs.Add(pathPrefix + ": either domain or address (lb_address in YAML) must be specified")
	}
	if cfg.Domain != "" {
		// Standard domain validation regex
		if matched, _ := regexp.MatchString(`^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$`, cfg.Domain); !matched {
			verrs.Add(pathPrefix + ".domain: '" + cfg.Domain + "' is not a valid domain name")
		}
	}
	if cfg.Address != "" {
		// Use net.ParseIP for IP validation since net is available in cluster_types.go
		// For now, we'll use a simple validation pattern
		if matched, _ := regexp.MatchString(`^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`, cfg.Address); !matched {
			verrs.Add(pathPrefix + ".address (lb_address): invalid IP address format for '" + cfg.Address + "'")
		}
	}

	if cfg.Port != 0 && (cfg.Port <= 0 || cfg.Port > 65535) { // Port 0 is defaulted
		verrs.Add(pathPrefix + ".port: invalid port " + fmt.Sprintf("%d", cfg.Port) + ", must be between 1-65535")
	}

	validExternalTypes := []string{"kubexm", "external", ""} // "" means not specified/use default or inferred
	found := false
	for _, vt := range validExternalTypes {
		if cfg.ExternalLoadBalancerType == vt {
			found = true
			break
		}
	}
	if !found {
		verrs.Add(pathPrefix + ".externalLoadBalancerType: invalid type '" + cfg.ExternalLoadBalancerType + "', must be one of " + fmt.Sprintf("%v", validExternalTypes) + " or empty")
	}

	validInternalTypes := []string{"haproxy", "nginx", "kube-vip", ""} // "" means not specified/use default or inferred
	found = false
	for _, vt := range validInternalTypes {
		if cfg.InternalLoadBalancerType == vt {
			found = true
			break
		}
	}
	if !found {
		verrs.Add(pathPrefix + ".internalLoadBalancerType (internalLoadbalancer): invalid type '" + cfg.InternalLoadBalancerType + "', must be one of " + fmt.Sprintf("%v", validInternalTypes) + " or empty")
	}
}

// isValidIP and containsString are expected to be defined in cluster_types.go or a shared util.
// For self-containedness, if they were local:
// func isValidIP(ip string) bool { return net.ParseIP(ip) != nil }
// func containsString(slice []string, item string) bool { for _, s := range slice { if s == item { return true } }; return false }
// NOTE: DeepCopy methods should be generated by controller-gen.
// Changed ExternalDNS to bool from *bool as per latest interpretation of the prompt.
// Updated YAML tags to match prompt: lb_address, externalLoadBalancer, internalLoadbalancer.
// Imported "net" and "regexp".
// Assumed ValidationErrors is defined in cluster_types.go.
// Added containsString from cluster_types.go (if it's not there, it needs to be added or imported).
// Added isValidIP from cluster_types.go (if it's not there, it needs to be added or imported).
