package v1alpha1

import (
	"fmt"
	"strings"
)

// Assuming ValidationErrors is in cluster_types.go or a shared util in this package
// Assuming containsString is in cluster_types.go or a shared util in this package

// ContainerRuntimeType defines the type of container runtime.
type ContainerRuntimeType string

const (
	ContainerRuntimeDocker     ContainerRuntimeType = "docker"
	ContainerRuntimeContainerd ContainerRuntimeType = "containerd"
	// Add other runtimes like cri-o, isula if supported by YAML in the future
)

// ContainerRuntimeConfig is a wrapper for specific container runtime configurations.
// It specifies the type of runtime and holds the specific configuration block.
type ContainerRuntimeConfig struct {
	// Type specifies the container runtime to use (e.g., "docker", "containerd").
	// Defaults to "docker" if not specified.
	Type ContainerRuntimeType `json:"type,omitempty" yaml:"type,omitempty"`

	// Version of the container runtime. This is a general version, specific versions
	// might also be present in DockerConfig or ContainerdConfig if needed for overrides.
	Version string `json:"version,omitempty" yaml:"version,omitempty"`

	// Docker holds Docker-specific configurations.
	// Only applicable if Type is "docker".
	Docker *DockerConfig `json:"docker,omitempty" yaml:"docker,omitempty"`

	// Containerd holds Containerd-specific configurations.
	// Only applicable if Type is "containerd".
	Containerd *ContainerdConfig `json:"containerd,omitempty" yaml:"containerd,omitempty"`
}

// SetDefaults_ContainerRuntimeConfig sets default values for ContainerRuntimeConfig.
func SetDefaults_ContainerRuntimeConfig(cfg *ContainerRuntimeConfig) {
	if cfg == nil {
		return
	}
	if cfg.Type == "" {
		cfg.Type = ContainerRuntimeDocker // Default to Docker
	}

	// Initialize and set defaults for the chosen runtime type
	if cfg.Type == ContainerRuntimeDocker {
		if cfg.Docker == nil {
			cfg.Docker = &DockerConfig{}
		}
		SetDefaults_DockerConfig(cfg.Docker) // Assumes SetDefaults_DockerConfig is in docker_types.go
	}

	if cfg.Type == ContainerRuntimeContainerd {
		if cfg.Containerd == nil {
			cfg.Containerd = &ContainerdConfig{}
		}
		SetDefaults_ContainerdConfig(cfg.Containerd) // Assumes SetDefaults_ContainerdConfig is in containerd_types.go
	}
}

// Validate_ContainerRuntimeConfig validates ContainerRuntimeConfig.
func Validate_ContainerRuntimeConfig(cfg *ContainerRuntimeConfig, verrs *ValidationErrors, pathPrefix string) {
	if cfg == nil {
		// This case might be an error if ContainerRuntime section is mandatory in ClusterSpec.
		// If it's optional and defaulted, this is fine. Assuming ClusterSpec defaults it.
		verrs.Add(pathPrefix, "containerRuntime section cannot be nil (should be defaulted if not present)")
		return
	}

	validTypes := []ContainerRuntimeType{ContainerRuntimeDocker, ContainerRuntimeContainerd, ""} // Allow empty for default
	isValid := false
	for _, vt := range validTypes {
		// Check if cfg.Type matches a valid type, or if cfg.Type is empty and vt is the default type.
		if cfg.Type == vt || (cfg.Type == "" && vt == ContainerRuntimeDocker) {
			isValid = true
			break
		}
	}
	if !isValid {
		verrs.Add(pathPrefix + ".type: invalid container runtime type '" + string(cfg.Type) + "', must be one of " + fmt.Sprintf("%v", validTypes) + " or empty for default")
	}

	// Validate specific config only if type matches
	if cfg.Type == ContainerRuntimeDocker {
		if cfg.Docker == nil {
			// This should ideally be caught by defaulting logic which initializes cfg.Docker.
			// If still nil, it's an issue or means Docker type was set without providing its config block.
			verrs.Add(pathPrefix+".docker", "docker config must be defined if type is 'docker'")
		} else {
			Validate_DockerConfig(cfg.Docker, verrs, pathPrefix+".docker") // Function defined in docker_types.go
		}
	} else if cfg.Docker != nil { // Docker config provided but type is not docker
		verrs.Add(pathPrefix+".docker", "docker config can only be set if type is 'docker'")
	}

	if cfg.Type == ContainerRuntimeContainerd {
		if cfg.Containerd == nil {
			verrs.Add(pathPrefix+".containerd", "containerd config must be defined if type is 'containerd'")
		} else {
			Validate_ContainerdConfig(cfg.Containerd, verrs, pathPrefix+".containerd") // Function defined in containerd_types.go
		}
	} else if cfg.Containerd != nil { // Containerd config provided but type is not containerd
		verrs.Add(pathPrefix+".containerd", "containerd config can only be set if type is 'containerd'")
	}

	// Version can be validated for format if needed, e.g., semantic versioning.
	if cfg.Version != "" && strings.TrimSpace(cfg.Version) == "" {
		verrs.Add(pathPrefix+".version", "version cannot be only whitespace if specified")
	}
}

// NOTE: DeepCopy methods should be generated by controller-gen.
// The DockerConfig and ContainerdConfig structs and their SetDefaults/Validate functions
// are defined in docker_types.go and containerd_types.go respectively.
// This file (container_runtime_types.go) now only defines the selector ContainerRuntimeConfig
// and its associated ContainerRuntimeType.
// Removed the local definitions of DockerConfig, ContainerdConfig and their methods.
