package resource

import (
	"fmt"
	"path/filepath"

	"github.com/mensylisir/kubexm/pkg/common"
	"github.com/mensylisir/kubexm/pkg/connector"
	"github.com/mensylisir/kubexm/pkg/plan"
	"github.com/mensylisir/kubexm/pkg/runtime"
	"github.com/mensylisir/kubexm/pkg/task"
)

// LocalCertificateHandle represents a certificate resource that is expected to be
// generated or placed locally on the control node.
type LocalCertificateHandle struct {
	// User-defined properties
	ResourceName string // e.g., "etcd", "kube-apiserver". Used to determine subdirectory under "certs".
	CertFileName string // e.g., "ca.pem", "server.key", "apiserver-etcd-client.pem"
	ClusterName  string // Explicitly pass cluster name for path construction

	// Internal
	controlNodeHost []connector.Host // Cached control node host object
}

// NewLocalCertificateHandle creates a new local certificate resource handle.
func NewLocalCertificateHandle(resourceName, certFileName, clusterName string) Handle {
	return &LocalCertificateHandle{
		ResourceName: resourceName, // This will define the subdirectory, e.g., "etcd"
		CertFileName: certFileName,
		ClusterName:  clusterName,
	}
}

func (h *LocalCertificateHandle) ID() string {
	return fmt.Sprintf("%s-%s-cert-%s", h.ResourceName, filepath.Base(h.CertFileName), h.ClusterName)
}

// getControlNode retrieves and caches the control node host object.
func (h *LocalCertificateHandle) getControlNode(ctx runtime.TaskContext) ([]connector.Host, error) {
	if h.controlNodeHost != nil {
		return h.controlNodeHost, nil
	}
	nodes, err := ctx.GetHostsByRole(common.ControlNodeRole)
	if err != nil {
		return nil, fmt.Errorf("failed to get control node for resource %s: %w", h.ID(), err)
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no control node found for resource %s", h.ID())
	}
	h.controlNodeHost = []connector.Host{nodes[0]} // Use the first control node
	return h.controlNodeHost, nil
}

// Path returns the expected final local path of the certificate on the control node.
// Structure: GlobalWorkDir (e.g., .kubexm)/${cluster_name}/certs/${h.ResourceName}/${h.CertFileName}
func (h *LocalCertificateHandle) Path(ctx runtime.TaskContext) string {
	if h.ClusterName == "" {
		ctx.GetLogger().Error("Cluster name is empty in LocalCertificateHandle, cannot determine resource path", "resource", h.ResourceName, "cert", h.CertFileName)
		return ""
	}
	// GlobalWorkDir is like $(pwd)/.kubexm
	// Path: $(pwd)/.kubexm/${cluster_name}/certs/${h.ResourceName}/${h.CertFileName}
	// Example: .kubexm/mycluster/certs/etcd/ca.pem
	return filepath.Join(ctx.GetGlobalWorkDir(), h.ClusterName, "certs", h.ResourceName, h.CertFileName)
}

// EnsurePlan for a LocalCertificateHandle primarily checks for the certificate's existence.
// The actual generation of the certificate is assumed to be handled by other dedicated steps
// (e.g., GenerateCACertStep, GenerateSignedCertStep) planned by a Task.
// This handle's role is to provide the standardized path and verify if it's already met.
func (h *LocalCertificateHandle) EnsurePlan(ctx runtime.TaskContext) (*task.ExecutionFragment, error) {
	logger := ctx.GetLogger().With("resource_handle", h.ID())
	nodes := make(map[plan.NodeID]*plan.ExecutionNode)

	controlNodeHosts, err := h.getControlNode(ctx)
	if err != nil {
		return nil, err
	}
	controlNode := controlNodeHosts[0]

	finalCertPath := h.Path(ctx)
	if finalCertPath == "" {
		return nil, fmt.Errorf("could not determine path for certificate %s due to missing cluster name", h.ID())
	}

	runner := ctx.GetRunner()
	conn, err := ctx.GetConnectorForHost(controlNode) // Should be LocalConnector
	if err != nil {
		return nil, fmt.Errorf("failed to get connector for control node: %w", err)
	}

	exists, err := runner.Exists(ctx.GoContext(), conn, finalCertPath)
	if err != nil {
		logger.Warn("Failed to check certificate existence, assuming it needs to be generated.", "path", finalCertPath, "error", err)
		// Proceed assuming it needs to be generated by other steps.
		// Return an empty fragment as this handle doesn't generate certs.
		return &task.ExecutionFragment{Nodes: nodes, EntryNodes: []plan.NodeID{}, ExitNodes: []plan.NodeID{}}, nil
	}

	if exists {
		logger.Info("Certificate already exists locally on control node. No action needed by this handle.", "path", finalCertPath)
	} else {
		logger.Info("Certificate does not exist locally. Its generation should be handled by dedicated steps in the task.", "path", finalCertPath)
	}

	// This handle does not create steps to generate the certificate.
	// It only provides the path and checks existence.
	// Tasks that *use* this certificate are responsible for planning its generation if needed.
	return &task.ExecutionFragment{Nodes: nodes, EntryNodes: []plan.NodeID{}, ExitNodes: []plan.NodeID{}}, nil
}

// Ensure LocalCertificateHandle implements the Handle interface.
var _ Handle = (*LocalCertificateHandle)(nil)
