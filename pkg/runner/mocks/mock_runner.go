// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/runner/interface.go
//
// Generated by this command:
//
//	mockgen -source=pkg/runner/interface.go -destination=pkg/runner/mocks/mock_runner.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	template "text/template"
	time "time"

	connector "github.com/mensylisir/kubexm/pkg/connector"
	runner "github.com/mensylisir/kubexm/pkg/runner"
	gomock "go.uber.org/mock/gomock"
)

// MockRunner is a mock of Runner interface.
type MockRunner struct {
	ctrl     *gomock.Controller
	recorder *MockRunnerMockRecorder
	isgomock struct{}
}

// MockRunnerMockRecorder is the mock recorder for MockRunner.
type MockRunnerMockRecorder struct {
	mock *MockRunner
}

// NewMockRunner creates a new mock instance.
func NewMockRunner(ctrl *gomock.Controller) *MockRunner {
	mock := &MockRunner{ctrl: ctrl}
	mock.recorder = &MockRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRunner) EXPECT() *MockRunnerMockRecorder {
	return m.recorder
}

// AddGroup mocks base method.
func (m *MockRunner) AddGroup(ctx context.Context, conn connector.Connector, groupname string, systemGroup bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddGroup", ctx, conn, groupname, systemGroup)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddGroup indicates an expected call of AddGroup.
func (mr *MockRunnerMockRecorder) AddGroup(ctx, conn, groupname, systemGroup any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddGroup", reflect.TypeOf((*MockRunner)(nil).AddGroup), ctx, conn, groupname, systemGroup)
}

// AddHostEntry mocks base method.
func (m *MockRunner) AddHostEntry(ctx context.Context, conn connector.Connector, ip, fqdn string, hostnames ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, conn, ip, fqdn}
	for _, a := range hostnames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddHostEntry", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddHostEntry indicates an expected call of AddHostEntry.
func (mr *MockRunnerMockRecorder) AddHostEntry(ctx, conn, ip, fqdn any, hostnames ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, conn, ip, fqdn}, hostnames...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddHostEntry", reflect.TypeOf((*MockRunner)(nil).AddHostEntry), varargs...)
}

// AddRepository mocks base method.
func (m *MockRunner) AddRepository(ctx context.Context, conn connector.Connector, facts *runner.Facts, repoConfig string, isFilePath bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddRepository", ctx, conn, facts, repoConfig, isFilePath)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddRepository indicates an expected call of AddRepository.
func (mr *MockRunnerMockRecorder) AddRepository(ctx, conn, facts, repoConfig, isFilePath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRepository", reflect.TypeOf((*MockRunner)(nil).AddRepository), ctx, conn, facts, repoConfig, isFilePath)
}

// AddUser mocks base method.
func (m *MockRunner) AddUser(ctx context.Context, conn connector.Connector, username, group, shell, homeDir string, createHome, systemUser bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddUser", ctx, conn, username, group, shell, homeDir, createHome, systemUser)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddUser indicates an expected call of AddUser.
func (mr *MockRunnerMockRecorder) AddUser(ctx, conn, username, group, shell, homeDir, createHome, systemUser any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUser", reflect.TypeOf((*MockRunner)(nil).AddUser), ctx, conn, username, group, shell, homeDir, createHome, systemUser)
}

// Check mocks base method.
func (m *MockRunner) Check(ctx context.Context, conn connector.Connector, cmd string, sudo bool) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check", ctx, conn, cmd, sudo)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Check indicates an expected call of Check.
func (mr *MockRunnerMockRecorder) Check(ctx, conn, cmd, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockRunner)(nil).Check), ctx, conn, cmd, sudo)
}

// Chmod mocks base method.
func (m *MockRunner) Chmod(ctx context.Context, conn connector.Connector, path, permissions string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", ctx, conn, path, permissions, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockRunnerMockRecorder) Chmod(ctx, conn, path, permissions, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockRunner)(nil).Chmod), ctx, conn, path, permissions, sudo)
}

// Chown mocks base method.
func (m *MockRunner) Chown(ctx context.Context, conn connector.Connector, path, owner, group string, recursive bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", ctx, conn, path, owner, group, recursive)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockRunnerMockRecorder) Chown(ctx, conn, path, owner, group, recursive any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockRunner)(nil).Chown), ctx, conn, path, owner, group, recursive)
}

// DaemonReload mocks base method.
func (m *MockRunner) DaemonReload(ctx context.Context, conn connector.Connector, facts *runner.Facts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DaemonReload", ctx, conn, facts)
	ret0, _ := ret[0].(error)
	return ret0
}

// DaemonReload indicates an expected call of DaemonReload.
func (mr *MockRunnerMockRecorder) DaemonReload(ctx, conn, facts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DaemonReload", reflect.TypeOf((*MockRunner)(nil).DaemonReload), ctx, conn, facts)
}

// DisableService mocks base method.
func (m *MockRunner) DisableService(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DisableService", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DisableService indicates an expected call of DisableService.
func (mr *MockRunnerMockRecorder) DisableService(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableService", reflect.TypeOf((*MockRunner)(nil).DisableService), ctx, conn, facts, serviceName)
}

// Download mocks base method.
func (m *MockRunner) Download(ctx context.Context, conn connector.Connector, facts *runner.Facts, url, destPath string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Download", ctx, conn, facts, url, destPath, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Download indicates an expected call of Download.
func (mr *MockRunnerMockRecorder) Download(ctx, conn, facts, url, destPath, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Download", reflect.TypeOf((*MockRunner)(nil).Download), ctx, conn, facts, url, destPath, sudo)
}

// DownloadAndExtract mocks base method.
func (m *MockRunner) DownloadAndExtract(ctx context.Context, conn connector.Connector, facts *runner.Facts, url, destDir string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DownloadAndExtract", ctx, conn, facts, url, destDir, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// DownloadAndExtract indicates an expected call of DownloadAndExtract.
func (mr *MockRunnerMockRecorder) DownloadAndExtract(ctx, conn, facts, url, destDir, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadAndExtract", reflect.TypeOf((*MockRunner)(nil).DownloadAndExtract), ctx, conn, facts, url, destDir, sudo)
}

// EnableService mocks base method.
func (m *MockRunner) EnableService(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnableService", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnableService indicates an expected call of EnableService.
func (mr *MockRunnerMockRecorder) EnableService(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableService", reflect.TypeOf((*MockRunner)(nil).EnableService), ctx, conn, facts, serviceName)
}

// Exists mocks base method.
func (m *MockRunner) Exists(ctx context.Context, conn connector.Connector, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", ctx, conn, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockRunnerMockRecorder) Exists(ctx, conn, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockRunner)(nil).Exists), ctx, conn, path)
}

// Extract mocks base method.
func (m *MockRunner) Extract(ctx context.Context, conn connector.Connector, facts *runner.Facts, archivePath, destDir string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Extract", ctx, conn, facts, archivePath, destDir, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Extract indicates an expected call of Extract.
func (mr *MockRunnerMockRecorder) Extract(ctx, conn, facts, archivePath, destDir, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Extract", reflect.TypeOf((*MockRunner)(nil).Extract), ctx, conn, facts, archivePath, destDir, sudo)
}

// GatherFacts mocks base method.
func (m *MockRunner) GatherFacts(ctx context.Context, conn connector.Connector) (*runner.Facts, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GatherFacts", ctx, conn)
	ret0, _ := ret[0].(*runner.Facts)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GatherFacts indicates an expected call of GatherFacts.
func (mr *MockRunnerMockRecorder) GatherFacts(ctx, conn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GatherFacts", reflect.TypeOf((*MockRunner)(nil).GatherFacts), ctx, conn)
}

// GetSHA256 mocks base method.
func (m *MockRunner) GetSHA256(ctx context.Context, conn connector.Connector, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSHA256", ctx, conn, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSHA256 indicates an expected call of GetSHA256.
func (mr *MockRunnerMockRecorder) GetSHA256(ctx, conn, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSHA256", reflect.TypeOf((*MockRunner)(nil).GetSHA256), ctx, conn, path)
}

// GroupExists mocks base method.
func (m *MockRunner) GroupExists(ctx context.Context, conn connector.Connector, groupname string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupExists", ctx, conn, groupname)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GroupExists indicates an expected call of GroupExists.
func (mr *MockRunnerMockRecorder) GroupExists(ctx, conn, groupname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupExists", reflect.TypeOf((*MockRunner)(nil).GroupExists), ctx, conn, groupname)
}

// InstallPackages mocks base method.
func (m *MockRunner) InstallPackages(ctx context.Context, conn connector.Connector, facts *runner.Facts, packages ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, conn, facts}
	for _, a := range packages {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InstallPackages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InstallPackages indicates an expected call of InstallPackages.
func (mr *MockRunnerMockRecorder) InstallPackages(ctx, conn, facts any, packages ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, conn, facts}, packages...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstallPackages", reflect.TypeOf((*MockRunner)(nil).InstallPackages), varargs...)
}

// IsDir mocks base method.
func (m *MockRunner) IsDir(ctx context.Context, conn connector.Connector, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir", ctx, conn, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDir indicates an expected call of IsDir.
func (mr *MockRunnerMockRecorder) IsDir(ctx, conn, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockRunner)(nil).IsDir), ctx, conn, path)
}

// IsPackageInstalled mocks base method.
func (m *MockRunner) IsPackageInstalled(ctx context.Context, conn connector.Connector, facts *runner.Facts, packageName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPackageInstalled", ctx, conn, facts, packageName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsPackageInstalled indicates an expected call of IsPackageInstalled.
func (mr *MockRunnerMockRecorder) IsPackageInstalled(ctx, conn, facts, packageName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPackageInstalled", reflect.TypeOf((*MockRunner)(nil).IsPackageInstalled), ctx, conn, facts, packageName)
}

// IsPortOpen mocks base method.
func (m *MockRunner) IsPortOpen(ctx context.Context, conn connector.Connector, facts *runner.Facts, port int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPortOpen", ctx, conn, facts, port)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsPortOpen indicates an expected call of IsPortOpen.
func (mr *MockRunnerMockRecorder) IsPortOpen(ctx, conn, facts, port any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPortOpen", reflect.TypeOf((*MockRunner)(nil).IsPortOpen), ctx, conn, facts, port)
}

// IsServiceActive mocks base method.
func (m *MockRunner) IsServiceActive(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsServiceActive", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsServiceActive indicates an expected call of IsServiceActive.
func (mr *MockRunnerMockRecorder) IsServiceActive(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsServiceActive", reflect.TypeOf((*MockRunner)(nil).IsServiceActive), ctx, conn, facts, serviceName)
}

// LookPath mocks base method.
func (m *MockRunner) LookPath(ctx context.Context, conn connector.Connector, file string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LookPath", ctx, conn, file)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LookPath indicates an expected call of LookPath.
func (mr *MockRunnerMockRecorder) LookPath(ctx, conn, file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookPath", reflect.TypeOf((*MockRunner)(nil).LookPath), ctx, conn, file)
}

// Mkdirp mocks base method.
func (m *MockRunner) Mkdirp(ctx context.Context, conn connector.Connector, path, permissions string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Mkdirp", ctx, conn, path, permissions, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Mkdirp indicates an expected call of Mkdirp.
func (mr *MockRunnerMockRecorder) Mkdirp(ctx, conn, path, permissions, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mkdirp", reflect.TypeOf((*MockRunner)(nil).Mkdirp), ctx, conn, path, permissions, sudo)
}

// MustRun mocks base method.
func (m *MockRunner) MustRun(ctx context.Context, conn connector.Connector, cmd string, sudo bool) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MustRun", ctx, conn, cmd, sudo)
	ret0, _ := ret[0].(string)
	return ret0
}

// MustRun indicates an expected call of MustRun.
func (mr *MockRunnerMockRecorder) MustRun(ctx, conn, cmd, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustRun", reflect.TypeOf((*MockRunner)(nil).MustRun), ctx, conn, cmd, sudo)
}

// ReadFile mocks base method.
func (m *MockRunner) ReadFile(ctx context.Context, conn connector.Connector, path string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", ctx, conn, path)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockRunnerMockRecorder) ReadFile(ctx, conn, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockRunner)(nil).ReadFile), ctx, conn, path)
}

// Remove mocks base method.
func (m *MockRunner) Remove(ctx context.Context, conn connector.Connector, path string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx, conn, path, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockRunnerMockRecorder) Remove(ctx, conn, path, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockRunner)(nil).Remove), ctx, conn, path, sudo)
}

// RemovePackages mocks base method.
func (m *MockRunner) RemovePackages(ctx context.Context, conn connector.Connector, facts *runner.Facts, packages ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, conn, facts}
	for _, a := range packages {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemovePackages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemovePackages indicates an expected call of RemovePackages.
func (mr *MockRunnerMockRecorder) RemovePackages(ctx, conn, facts any, packages ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, conn, facts}, packages...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePackages", reflect.TypeOf((*MockRunner)(nil).RemovePackages), varargs...)
}

// Render mocks base method.
func (m *MockRunner) Render(ctx context.Context, conn connector.Connector, tmpl *template.Template, data any, destPath, permissions string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Render", ctx, conn, tmpl, data, destPath, permissions, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// Render indicates an expected call of Render.
func (mr *MockRunnerMockRecorder) Render(ctx, conn, tmpl, data, destPath, permissions, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRunner)(nil).Render), ctx, conn, tmpl, data, destPath, permissions, sudo)
}

// RestartService mocks base method.
func (m *MockRunner) RestartService(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestartService", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(error)
	return ret0
}

// RestartService indicates an expected call of RestartService.
func (mr *MockRunnerMockRecorder) RestartService(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestartService", reflect.TypeOf((*MockRunner)(nil).RestartService), ctx, conn, facts, serviceName)
}

// Run mocks base method.
func (m *MockRunner) Run(ctx context.Context, conn connector.Connector, cmd string, sudo bool) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx, conn, cmd, sudo)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockRunnerMockRecorder) Run(ctx, conn, cmd, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRunner)(nil).Run), ctx, conn, cmd, sudo)
}

// RunWithOptions mocks base method.
func (m *MockRunner) RunWithOptions(ctx context.Context, conn connector.Connector, cmd string, opts *connector.ExecOptions) ([]byte, []byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWithOptions", ctx, conn, cmd, opts)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].([]byte)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// RunWithOptions indicates an expected call of RunWithOptions.
func (mr *MockRunnerMockRecorder) RunWithOptions(ctx, conn, cmd, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWithOptions", reflect.TypeOf((*MockRunner)(nil).RunWithOptions), ctx, conn, cmd, opts)
}

// SetHostname mocks base method.
func (m *MockRunner) SetHostname(ctx context.Context, conn connector.Connector, facts *runner.Facts, hostname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetHostname", ctx, conn, facts, hostname)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetHostname indicates an expected call of SetHostname.
func (mr *MockRunnerMockRecorder) SetHostname(ctx, conn, facts, hostname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHostname", reflect.TypeOf((*MockRunner)(nil).SetHostname), ctx, conn, facts, hostname)
}

// StartService mocks base method.
func (m *MockRunner) StartService(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartService", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartService indicates an expected call of StartService.
func (mr *MockRunnerMockRecorder) StartService(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartService", reflect.TypeOf((*MockRunner)(nil).StartService), ctx, conn, facts, serviceName)
}

// StopService mocks base method.
func (m *MockRunner) StopService(ctx context.Context, conn connector.Connector, facts *runner.Facts, serviceName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopService", ctx, conn, facts, serviceName)
	ret0, _ := ret[0].(error)
	return ret0
}

// StopService indicates an expected call of StopService.
func (mr *MockRunnerMockRecorder) StopService(ctx, conn, facts, serviceName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopService", reflect.TypeOf((*MockRunner)(nil).StopService), ctx, conn, facts, serviceName)
}

// UpdatePackageCache mocks base method.
func (m *MockRunner) UpdatePackageCache(ctx context.Context, conn connector.Connector, facts *runner.Facts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdatePackageCache", ctx, conn, facts)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdatePackageCache indicates an expected call of UpdatePackageCache.
func (mr *MockRunnerMockRecorder) UpdatePackageCache(ctx, conn, facts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePackageCache", reflect.TypeOf((*MockRunner)(nil).UpdatePackageCache), ctx, conn, facts)
}

// UserExists mocks base method.
func (m *MockRunner) UserExists(ctx context.Context, conn connector.Connector, username string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserExists", ctx, conn, username)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserExists indicates an expected call of UserExists.
func (mr *MockRunnerMockRecorder) UserExists(ctx, conn, username any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockRunner)(nil).UserExists), ctx, conn, username)
}

// WaitForPort mocks base method.
func (m *MockRunner) WaitForPort(ctx context.Context, conn connector.Connector, facts *runner.Facts, port int, timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForPort", ctx, conn, facts, port, timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForPort indicates an expected call of WaitForPort.
func (mr *MockRunnerMockRecorder) WaitForPort(ctx, conn, facts, port, timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForPort", reflect.TypeOf((*MockRunner)(nil).WaitForPort), ctx, conn, facts, port, timeout)
}

// WriteFile mocks base method.
func (m *MockRunner) WriteFile(ctx context.Context, conn connector.Connector, content []byte, destPath, permissions string, sudo bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", ctx, conn, content, destPath, permissions, sudo)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockRunnerMockRecorder) WriteFile(ctx, conn, content, destPath, permissions, sudo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockRunner)(nil).WriteFile), ctx, conn, content, destPath, permissions, sudo)
}
