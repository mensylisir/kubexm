# 2-9

好的，我们已经为 kubexms 设计了强大的内核和专业的命令行接口。现在，为了让它能够被其他系统集成或通过 Web UI 进行管理，设计一个 RESTful API 服务是至关重要的一步。

我们将使用 Go 生态中广受欢迎的 Gin 框架来构建这个 rest 包，因为它以高性能和易用性著称。

---

### **rest 包设计：提供 API 服务**

### **设计哲学**

1. **RESTful 原则**: 遵循标准的 RESTful 设计原则，使用 HTTP 方法（GET, POST, DELETE）和资源路径（/api/v1/clusters, /api/v1/clusters/{clusterName}）来表达操作。
2. **清晰的分层**: API 层应该严格分离。Handler 负责处理 HTTP 请求和响应，Service 负责业务逻辑编排，Controller (或直接调用我们的 pipeline 层) 负责与核心引擎交互。
3. **标准化响应 (Standardized Response)**: 所有 API 响应都应该遵循一个统一的 JSON 结构，方便前端或客户端进行统一处理。
4. **异步任务处理 (Asynchronous Task Handling)**: 像“创建集群”这样的长时间运行任务，必须是异步的。API 应该立即返回一个任务 ID，并提供另一个端点来查询任务状态。
5. **状态管理 (State Management)**: API 服务需要一个地方来存储集群的配置、状态以及异步任务的进度。这通常需要一个简单的数据库（如 SQLite）或一个键值存储（如 BoltDB）。
6. **认证与授权 (Authentication & Authorization)**: 生产级的 API 必须有认证机制（如 JWT, API Key）来保护其安全。

### **包结构 rest**

`pkg/rest/
├── server.go          # 定义和启动 HTTP 服务器
├── router.go          # 定义所有 API 路由
├── handlers/
│   ├── cluster.go     # 处理与集群资源相关的 HTTP 请求
│   └── task.go        # 处理与异步任务相关的 HTTP 请求
├── services/
│   ├── cluster_service.go # 封装创建/删除集群的业务逻辑
│   └── task_service.go    # 封装异步任务的管理逻辑
├── models/
│   ├── request.go     # 定义 API 请求体的数据结构
│   └── response.go    # 定义标准 API 响应的数据结构
└── store/
├── interface.go   # 定义数据存储的接口
└── boltdb/        # 使用 BoltDB 实现存储接口 (嵌入式 K/V 数据库)`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

---

### **详细文件设计**

### **models/response.go - 标准响应模型**

`package models

// Response 是所有 API 响应的统一格式
type Response struct {
Code    int         `json:"code"`    // 业务状态码, e.g., 200 for success
Message string      `json:"message"` // 提示信息
Data    interface{} `json:"data"`    // 实际的响应数据
}

// Success 快速创建一个成功的响应
func Success(data interface{}) Response {
return Response{Code: 200, Message: "success", Data: data}
}

// Error 快速创建一个失败的响应
func Error(code int, message string) Response {
return Response{Code: code, Message: message, Data: nil}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **models/request.go - 请求模型**

`package models

// CreateClusterRequest 定义了创建集群 API 的请求体
type CreateClusterRequest struct {
Name          string `json:"name" binding:"required"`
Configuration string `json:"configuration" binding:"required"` // Base64 编码的 cluster.yaml 内容
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **store/ - 数据存储层**

这一层负责持久化。

`package store

// Store 定义了持久化存储所需的所有方法
type Store interface {
// Cluster methods
CreateCluster(name string, configYAML string) error
GetCluster(name string) (*Cluster, error)
ListClusters() ([]*Cluster, error)
DeleteCluster(name string) error

	// Task methods
	CreateTask(task *Task) (string, error) // 返回任务 ID
	GetTask(id string) (*Task, error)
	UpdateTaskStatus(id string, status string, logs string) error
}

// Cluster 和 Task 是存储在数据库中的数据模型
type Cluster struct { /* ... name, config, status ... */ }
type Task struct { /* ... id, type, status, logs, creationTime ... */ }`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

这个目录会使用 bbolt 库来实现 Store 接口，将数据存储在本地文件中。

---

### **services/ - 业务逻辑层**

`package services

// TaskService 封装了与任务相关的业务逻辑
type TaskService struct {
Store store.Store
}

// ... NewTaskService, GetTask, etc. ...`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

这是核心业务逻辑所在。

`package services

import (
"context"
"encoding/base64"
"github.com/google/uuid"
"github.com/kubexms/kubexms/pkg/config"
"github.com/kubexms/kubexms/pkg/pipeline"
"github.com/kubexms/kubexms/pkg/runtime"
"github.com/kubexms/kubexms/pkg/rest/store"
)

type ClusterService struct {
Store store.Store
}

func NewClusterService(s store.Store) *ClusterService {
return &ClusterService{Store: s}
}

// CreateClusterAsync 是一个异步方法，它创建一个任务并立即返回
func (s *ClusterService) CreateClusterAsync(req models.CreateClusterRequest) (string, error) {
// 1. 在数据库中创建集群记录
if err := s.Store.CreateCluster(req.Name, req.Configuration); err != nil {
return "", err
}

	// 2. 创建一个异步任务
	taskID, err := s.Store.CreateTask(&store.Task{
		ID:   uuid.NewString(),
		Type: "CreateCluster",
		Status: "Pending",
	})
	if err != nil {
		return "", err
	}
	
	// 3. 在一个新的 goroutine 中执行耗时的集群创建过程
	go s.runCreateClusterTask(taskID, req.Configuration)

	return taskID, nil
}

// runCreateClusterTask 是真正在后台运行的函数
func (s *ClusterService) runCreateClusterTask(taskID string, configBase64 string) {
var taskLogs strings.Builder

	// 更新任务状态为 Running
	s.Store.UpdateTaskStatus(taskID, "Running", "")

	// 伪造一个 writer，将日志写入 taskLogs
	logWriter := &taskLogs 
	logger := util.NewZapLoggerForWriter(logWriter)

	// 解码配置
	yamlBytes, err := base64.StdEncoding.DecodeString(configBase64)
	if err != nil { /* ... update task status to Failed ... */ return }
	
	cfg, err := config.LoadFromBytes(yamlBytes)
	if err != nil { /* ... update task status to Failed ... */ return }

	// 创建 Runtime
	clusterRuntime, err := runtime.NewRuntime(cfg, logger)
	if err != nil { /* ... update task status to Failed ... */ return }

	// 创建并运行 Pipeline
	p := pipeline.NewCreateClusterPipeline(cfg)
	if err := p.Run(context.Background(), clusterRuntime); err != nil {
		// 如果失败，记录日志并更新任务状态
		s.Store.UpdateTaskStatus(taskID, "Failed", taskLogs.String() + "\nError: " + err.Error())
		return
	}
	
	// 如果成功，更新任务状态
	s.Store.UpdateTaskStatus(taskID, "Succeeded", taskLogs.String())
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **handlers/ - HTTP 请求处理层**

`package handlers

import (
"github.com/gin-gonic/gin"
"github.com/kubexms/kubexms/pkg/rest/models"
"github.com/kubexms/kubexms/pkg/rest/services"
"net/http"
)

type ClusterHandler struct {
Service *services.ClusterService
}

func NewClusterHandler(s *services.ClusterService) *ClusterHandler {
return &ClusterHandler{Service: s}
}

// CreateCluster 处理 POST /api/v1/clusters
func (h *ClusterHandler) CreateCluster(c *gin.Context) {
var req models.CreateClusterRequest
if err := c.ShouldBindJSON(&req); err != nil {
c.JSON(http.StatusBadRequest, models.Error(400, "Invalid request body: "+err.Error()))
return
}

	taskID, err := h.Service.CreateClusterAsync(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.Error(500, "Failed to create task: "+err.Error()))
		return
	}

	// 立即返回，告知客户端任务已创建
	c.JSON(http.StatusAccepted, models.Success(gin.H{
		"taskId": taskID,
	}))
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`package handlers

// ... TaskHandler ...

// GetTaskStatus 处理 GET /api/v1/tasks/{id}
func (h *TaskHandler) GetTaskStatus(c *gin.Context) {
taskID := c.Param("id")
task, err := h.Service.GetTask(taskID)
if err != nil {
// ... handle error ...
}
c.JSON(http.StatusOK, models.Success(task))
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **router.go 和 server.go**

`package rest

func SetupRouter(deps *Dependencies) *gin.Engine {
r := gin.Default()

	// 创建所有 handlers
	clusterHandler := handlers.NewClusterHandler(deps.ClusterService)
	taskHandler := handlers.NewTaskHandler(deps.TaskService)

	// API v1 group
	v1 := r.Group("/api/v1")
	{
		clusters := v1.Group("/clusters")
		{
			clusters.POST("", clusterHandler.CreateCluster)
			// ... GET, DELETE ...
		}
		
		tasks := v1.Group("/tasks")
		{
			tasks.GET("/:id", taskHandler.GetTaskStatus)
		}
	}
	return r
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

`package rest

// Dependencies 结构体用于依赖注入
type Dependencies struct { /* ... all services ... */ }

// RunServer 是启动 API 服务的入口
func RunServer() {
// 1. 初始化数据库
db, _ := store.NewBoltDBStore("kubexms.db")

	// 2. 初始化所有 services
	clusterSvc := services.NewClusterService(db)
	taskSvc := services.NewTaskService(db)
	
	deps := &Dependencies{ClusterService: clusterSvc, TaskService: taskSvc}
	
	// 3. 设置路由
	r := SetupRouter(deps)
	
	// 4. 启动服务器
	r.Run(":8080")
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **总结：rest 包**

这个设计为 kubexms 提供了一个功能完备、可扩展的 RESTful API 服务：

1. **分层清晰**: Handler -> Service -> Store 的分层结构使得代码易于维护和测试。
2. **异步处理**: 通过后台 goroutine 和任务状态查询，解决了长时间运行任务阻塞 API 的问题。
3. **持久化**: 使用嵌入式数据库 BoltDB 来存储集群和任务状态，使得服务重启后数据不丢失。
4. **标准化**: 统一的请求和响应模型方便了客户端的开发。
5. **可扩展**: 添加新的 API 只需要创建新的 Handler 和 Service，并在 router.go 中注册即可。

这个 rest 包使得 kubexms 不再仅仅是一个命令行工具，而升级为了一个可以被轻松集成的、强大的后端服务。