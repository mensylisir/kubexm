### pkg/task - 战术规划单元 (设计变更)
#### Task 不再生成一个自包含的、线性的 ExecutionPlan。相反，它现在生成一个子图 (sub-graph)，并返回这个子图的入口节点 (entry points)和出口节点 (exit points)。这使得上层 (Module) 可以将多个 Task 的子图“链接”起来。
#### task.ExecutionFragment 结构体 (新增):
##### 这是一个新的数据结构，用于表示 Task 生成的规划结果。
###### task_excution_fragment.go
```aiignore
package task

import "github.com/mensylisir/kubexm/pkg/plan"

// ExecutionFragment represents a piece of the total execution graph,
// generated by a single task.
type ExecutionFragment struct {
    // Nodes contains all the execution nodes for this task.
    Nodes map[plan.NodeID]*plan.ExecutionNode
    
    // EntryNodes are the IDs of nodes in this fragment that have no dependencies within the fragment.
    // The module layer will link dependencies TO these nodes.
    EntryNodes []plan.NodeID

    // ExitNodes are the IDs of nodes in this fragment that are not depended upon by any other node within the fragment.
    // The module layer will link dependencies FROM these nodes.
    ExitNodes []plan.NodeID
}

```
### task.Task 接口 (变更):
##### Plan 方法的返回值类型发生了根本性变化。
###### interface.go
```aiignore
package task

import (
    "github.com/mensylisir/kubexm/pkg/runtime"
)

// TaskContext defines the methods available at the task execution level.
type TaskContext interface {
	// Methods from former embedded ModuleContext (which were from PipelineContext)
	GoContext() context.Context
	GetLogger() *logger.Logger
	GetClusterConfig() *v1alpha1.Cluster
	PipelineCache() cache.PipelineCache
	GetGlobalWorkDir() string
	// GetEngine() engine.Engine // Removed

	// Methods from former embedded ModuleContext (module-specific)
	ModuleCache() cache.ModuleCache

	// Task-specific methods
	GetHostsByRole(role string) ([]connector.Host, error)
	GetHostFacts(host connector.Host) (*runner.Facts, error)
	TaskCache() cache.TaskCache
	GetControlNode() (connector.Host, error)
}

// ExecutionFragment represents a piece of the total execution graph.
type ExecutionFragment struct {
    Nodes      map[plan.NodeID]*plan.ExecutionNode
    EntryNodes []plan.NodeID // Nodes with no dependencies within this fragment.
    ExitNodes  []plan.NodeID // Nodes not depended upon by any other node in this fragment.
}

type Task interface {
    Name() string
    
    // Description provides a brief summary of what the task does.
	// This can be removed if not strictly needed by the new model,
	// or kept for informational purposes. For now, I'll keep it.
	Description() string

    IsRequired(ctx runtime.TaskContext) (bool, error)

    // Plan now generates an ExecutionFragment, a self-contained subgraph
    // with defined entry and exit points for linking.
    Plan(ctx runtime.TaskContext) (*ExecutionFragment, error)
}

```
#### 设计解读:
- Task 现在是一个独立的“图构建器”。它构建一个包含内部依赖关系的小型图。
通过暴露 EntryNodes 和 ExitNodes，Task 为上层提供了“连接点”，使得多个Task的图可以被组装成一个更大的图。


#### 职责:
- 读取配置: 从 ctx.GetClusterConfig() 获取用户定义的参数，如版本号、特性开关等。
- 条件性规划 (Conditional Planning): 根据配置决定是否需要执行某些操作。例如，如果 cluster.spec.monitoring.enabled 为 false，那么“安装Prometheus”的 Task 的 IsRequired 方法就可以直接返回 false。
- 参数化节点 (Parameterized Nodes): 使用配置中的值来参数化 Step。例如，下载 etcd 的 Step 的 URL 会根据 cluster.spec.etcd.version 来动态构建。
- 结构性规划 (Structural Planning): 配置还可以影响图的结构。例如，如果 cluster.spec.etcd.external 为 true，则“安装Etcd”的 Task 可能会跳过所有与etcd相关的节点。