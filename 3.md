# 2-3

好的，非常高兴我们达成了共识！现在我将为您呈现 pkg/runtime 这一层的最终、完整、详细的设计。这个设计将严格遵循我们讨论过的原则：Runtime 负责创建和管理整个执行环境，包括为每个 Host 配备好其专属的 Runner。

---

### **Part 3: pkg/runtime - 运行时环境 (最终完整版)**

- **核心职责**:
    1. **环境初始化**: 从用户配置中创建和管理整个主机清单 (Host 列表)。
    2. **工具配备**: 为清单中的每个 Host，负责创建其底层的 Connector 和功能强大的 Runner。
    3. **上下文提供**: 定义并创建 Context 对象，作为执行期间信息和工具的载体。
    4. **全局状态容器**: 作为 ClusterRuntime，持有整个流程的全局只读信息（如配置、主机列表、日志记录器）。
    5. **无执行逻辑**: 本身不包含 Engine 或任何 Run* 方法，只提供环境。

### **包结构 pkg/runtime**

`pkg/runtime/
├── runtime.go      # 定义核心数据结构 (Host, Context, ClusterRuntime) 和工厂函数 NewRuntime
└── errors.go       # 定义 Runtime 相关的错误`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).

---

### **文件 pkg/runtime/errors.go**

`package runtime

import "fmt"

// InitializationError 表示在创建 ClusterRuntime 期间发生的错误。
// 它可以包含多个子错误，因为主机的初始化是并发的。
type InitializationError struct {
SubErrors []error
}

func (e *InitializationError) Error() string {
if len(e.SubErrors) == 1 {
return fmt.Sprintf("runtime initialization failed: %v", e.SubErrors[0])
}
return fmt.Sprintf("runtime initialization failed with %d errors: %v", len(e.SubErrors), e.SubErrors)
}

func (e *InitializationError) Add(err error) {
if err != nil {
e.SubErrors = append(e.SubErrors, err)
}
}

func (e *InitializationError) IsEmpty() bool {
return len(e.SubErrors) == 0
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

---

### **文件 pkg/runtime/runtime.go**

`package runtime

import (
"context"
"fmt"
"sync"
"time"

	"github.com/kubexms/kubexms/pkg/config" // 假设这是解析 cluster.yaml 后的配置包
	"github.com/kubexms/kubexms/pkg/connector"
	"github.com/kubexms/kubexms/pkg/runner"
	"go.uber.org/zap"
)

// Host 包含了描述一个目标节点的所有信息。
// 它是一个自包含的、可操作的单元，是整个框架中与远程主机交互的句柄。
type Host struct {
Name            string            // 唯一主机名，例如 "master1"
Address         string            // 用于连接的地址 (IP or FQDN)
InternalAddress string            // 集群内部通信地址
Port            int               // 连接端口
User            string            // SSH 用户
Roles           map[string]bool   // 主机拥有的角色, e.g., {"etcd": true, "master": true}
Labels          map[string]string // 自定义标签，用于更灵活的主机分组

	// Runner 是与此主机绑定的、功能强大的操作执行器。
	// 它的生命周期由 Runtime 在初始化时管理，并在此与 Host 对象绑定。
	Runner *runner.Runner
}

// ClusterRuntime 包含了在整个 Pipeline 执行期间的全局只读信息。
// 它的核心是作为所有 Host 对象的“清单”或“管理器”。
type ClusterRuntime struct {
ClusterConfig interface{}      // 解析后的用户配置 (e.g., *config.Cluster)，以 interface{} 形式存储以保持通用性。
Hosts         []*Host          // 集群中的所有主机清单，按配置顺序排列。
Inventory     map[string]*Host // 通过主机名快速查找 Host 的索引。
Logger        *zap.Logger      // 全局日志记录器。
}

// Context 是在执行期间传递给每个 Step 的动态上下文。
// 它就像一个“行李箱”，携带了执行一个原子操作所需的所有工具和信息。
type Context struct {
// GoContext 用于支持超时和取消信号的传播。
GoContext context.Context
// Host 是当前正在执行操作的目标主机。
Host *Host
// Cluster 包含了对整个集群运行时状态的只读引用。
Cluster *ClusterRuntime
// Logger 是一个带有上下文（如主机名、步骤名）的日志记录器，用于结构化日志。
Logger *zap.SugaredLogger
// SharedData 是一个并发安全的 map，用于在**同一个主机**的不同 Step 之间传递动态生成的数据。
// 例如，一个 Step 生成了证书路径，另一个 Step 需要使用它。
SharedData *sync.Map
}

// NewRuntime 是 Runtime 的工厂函数。
// 它的核心职责是解析配置，创建所有 Host 实例，并为它们初始化底层的 Connector 和 Runner。
func NewRuntime(cfg *config.Cluster, logger *zap.Logger) (*ClusterRuntime, error) {
if logger == nil {
// 如果外部没有提供 logger，创建一个默认的生产级 logger
var err error
logger, err = zap.NewProduction()
if err != nil {
return nil, fmt.Errorf("failed to create default logger: %w", err)
}
}

	hosts := make([]*Host, 0, len(cfg.Spec.Hosts))
	inventory := make(map[string]*Host, len(cfg.Spec.Hosts))

	// 使用带超时的 context 来控制整个初始化过程
	// 假设配置中有全局超时: cfg.Spec.Global.ConnectionTimeout
	// 如果没有则设置一个合理的默认值，例如 30 秒。
	timeout := 30 * time.Second
	if cfg.Spec.Global.ConnectionTimeout > 0 {
		timeout = cfg.Spec.Global.ConnectionTimeout
	}
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// 并发初始化所有主机连接
	var wg sync.WaitGroup
	var mu sync.Mutex
	initErrs := &InitializationError{}

	for _, hostCfg := range cfg.Spec.Hosts {
		wg.Add(1)
		go func(hCfg config.HostSpec) {
			defer wg.Done()

			// 1. 创建 Connector 配置
			connCfg := connector.ConnectionCfg{
				Host:           hCfg.Address,
				Port:           hCfg.Port,
				User:           hCfg.User,
				Password:       hCfg.Password,
				PrivateKeyPath: hCfg.PrivateKeyPath,
				Timeout:        timeout,
				// Bastion support can be added here if config supports it
			}
			
			// 2. 创建 Connector 实例
			// 这里可以根据配置选择不同的 Connector, e.g., if hCfg.Type == "local"
			conn := &connector.SSHConnector{} // 默认为 SSH

			// 3. 建立连接
			if err := conn.Connect(ctx, connCfg); err != nil {
				initErrs.Add(fmt.Errorf("host %s connection failed: %w", hCfg.Address, err))
				return
			}
			
			// 4. 创建 Runner
			run, err := runner.NewRunner(ctx, conn)
			if err != nil {
				initErrs.Add(fmt.Errorf("host %s runner initialization failed: %w", hCfg.Address, err))
				return
			}
			
			// 5. 创建 runtime.Host 对象
			newHost := &Host{
				Name:            hCfg.Name,
				Address:         hCfg.Address,
				InternalAddress: hCfg.InternalAddress,
				Port:            hCfg.Port,
				User:            hCfg.User,
				Roles:           make(map[string]bool),
				Labels:          hCfg.Labels,
				Runner:          run,
			}
			for _, role := range hCfg.Roles {
				newHost.Roles[role] = true
			}

			// 使用互斥锁保护共享切片和 map 的写入
			mu.Lock()
			hosts = append(hosts, newHost)
			inventory[newHost.Name] = newHost
			mu.Unlock()

		}(hostCfg)
	}

	wg.Wait()

	if !initErrs.IsEmpty() {
		return nil, initErrs
	}
    
    // 按配置文件中的顺序对 hosts 进行排序，保证执行的可预测性
    // ... (如果并发导致顺序打乱，可以在这里根据 cfg.Spec.Hosts 的顺序重新排序)

	return &ClusterRuntime{
		ClusterConfig: cfg,
		Hosts:         hosts,
		Inventory:     inventory,
		Logger:        logger,
	}, nil
}

// NewHostContext 创建一个新的、针对特定主机的 Context。
func NewHostContext(goCtx context.Context, host *Host, cluster *ClusterRuntime) *Context {
return &Context{
GoContext:  goCtx,
Host:       host,
Cluster:    cluster,
Logger:     cluster.Logger.Sugar().With("host", host.Name),
SharedData: &sync.Map{},
}
}`

**content_copydownload**Use code [**with caution**](https://support.google.com/legal/answer/13505487).Go

### **总结：第三部分**

我们已经完成了一个纯粹、健壮且职责单一的 Runtime 层。它的核心价值在于：

1. **环境的自动化配置**: NewRuntime 函数是整个框架的“点火”开关，它将声明式的用户配置（YAML）转化为了一个立即可用的、包含所有连接和工具的**可编程环境** (ClusterRuntime)。
2. **清晰的所有权**: Runtime 创建并初始化 Runner，然后将其所有权交给 Host 对象。这种模式既符合“Runtime 管理 Runner”的逻辑，又提供了面向对象的、清晰的操作接口 (Host.Runner)。
3. **完全解耦**: Runtime 层不包含任何与 Pipeline、Module、Task 或 Step 相关的执行逻辑，只提供它们执行时所必需的环境和上下文。

至此，框架的“地基”（Connector）、“肌肉”（Runner）和“环境”（Runtime）都已设计完毕。接下来，我们将在这个坚实的基础上，构建上层的业务逻辑骨架，从 Step 开始。